<section class='introduction'><h1>WebSocket tutorial using Swift and Hummingbird</h1></section><section class='details literature'><p>In this article, you will learn about WebSockets and how to use them with the Hummingbird framework in a straightforward, easy-to-follow manner. The first part will give a clear understanding of what the WebSocket protocol is. After that, a hands-on example will be created using the Hummingbird WebSocket library, showing how to use this technology effectively.</p><h2 id='What%20is%20a%20WebSocket?'><a href='#What%20is%20a%20WebSocket?'>What is a WebSocket?</a></h2><p>WebSocket is a communication protocol that enables two-way, real-time interaction between an HTTP client and server. It is designed to work over a single, long-lived connection, which significantly reduces overhead compared to traditional HTTP request-response cycles. This protocol uses HTTP 1 to establish the connection, and then upgrades it to the WebSocket protocol, allowing both the client and server to send and receive messages asynchronously.</p><p>WebSockets are particularly useful for applications that require low latency and high-frequency updates, such as online gaming, chat applications, and live data feeds. The protocol supports full-duplex communication, meaning data can be sent and received simultaneously. This efficient data transfer method helps in creating more interactive applications, providing a smoother user experience.</p><h2 id='WebSockets%20vs%20Alternatives'><a href='#WebSockets%20vs%20Alternatives'>WebSockets vs Alternatives</a></h2><p>Similar to WebSockets, there are other methods of achieving real-time capabilities. Techniques like HTTP polling, HTTP streaming, Comet, and SSE (server-sent events) come to mind. Let’s explore how these methods differ.</p><h3 id='Long%20polling%20(HTTP%20polling)'><a href='#Long%20polling%20(HTTP%20polling)'>Long polling (HTTP polling)</a></h3><p>Long polling (HTTP polling) was one of the first methods to address real-time data fetching. It involved the client repeatedly sending requests to the server. The server holds the request open until there’s new data or a timeout occurs. Once data is available, the server responds, and the client immediately sends a new request. However, long polling has several issues, including header overhead, latency, timeouts, and caching problems.</p><h3 id='HTTP%20streaming'><a href='#HTTP%20streaming'>HTTP streaming</a></h3><p>HTTP streaming reduces network latency by keeping the initial request open indefinitely. Unlike long polling, the server does not close the connection after sending data; it keeps it open to send new updates whenever there is a change.</p><h3 id='SSE%20-%20Server-sent%20events'><a href='#SSE%20-%20Server-sent%20events'>SSE - Server-sent events</a></h3><p>Server-sent events (SSE) allow the server to push data to the client, similar to HTTP streaming. SSE is a standardized version of HTTP streaming and includes a built-in browser API. However, SSE is not suitable for applications like chats or games that require two-way communication since it only allows a one-way data flow from the server to the client. SSE uses traditional HTTP and has limitations on the number of open connections.</p><h2 id='Why%20to%20use%20WebSockets?'><a href='#Why%20to%20use%20WebSockets?'>Why to use WebSockets?</a></h2><p>The above methods are less efficient on a protocol level and often seem like workarounds to make a request-reply protocol appear full-duplex. WebSockets are designed for full-duplex communication, and are more lightweight than its alternatives.</p><h3 id='Security%20(WSS)'><a href='#Security%20(WSS)'>Security (WSS)</a></h3><p>WebSocket (WS) uses a plain-text TCP connection. A WebSocket connection is created by upgrading an HTTP/1 connection. WebSocket Secure (WSS), which is upgraded from HTTPS, uses TLS to protect the TCP connection. WSS protects against man-in-the-middle attacks but does not offer cross-origin or application-level security. Developers should add URL origin checks and strong authentication.</p><h2 id='Building%20a%20real-time%20WebSocket%20chat'><a href='#Building%20a%20real-time%20WebSocket%20chat'>Building a real-time WebSocket chat</a></h2><p>The <a href='https://github.com/hummingbird-project/hummingbird-websocket' target='_blank' rel='external'>Hummingbird Websocket</a> library is an extension for the Hummingbird web framework. This library provides WebSocket Client- and Serve support using the latest structured concurrency features like <code><a href='https://swiftinit.org/docs/swift/_concurrency/taskgroup' target='_blank' rel='external'>TaskGroup</a></code> and <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence' target='_blank' rel='external'>AsyncSequence</a></code>s.</p><p>The <a href='https://github.com/hummingbird-project/hummingbird-examples/tree/main/websocket-chat' target='_blank' rel='external'>Hummingbird WebSocket chat application</a> example demonstrates using web sockets for real-time communication. For an even simpler example, see the <a href='https://github.com/hummingbird-project/hummingbird-examples/tree/main/websocket-echo' target='_blank' rel='external'>echo server</a> example. This article will explore the chat application step-by-step. Let’s begin with the directory structure.</p><pre class='snippet'><code class='language-sh'><span class='newline'></span>.<span class='newline'>
</span>├── Package.resolved<span class='newline'>
</span>├── Package.swift<span class='newline'>
</span>├── README.md<span class='newline'>
</span>├── Sources<span class='newline'>
</span>│   └── App<span class='newline'>
</span>│       ├── App.swift<span class='newline'>
</span>│       ├── Application+build.swift<span class='newline'>
</span>│       └── ConnectionManager.swift<span class='newline'>
</span>└── public<span class='newline'>
</span>    └── chat.html</code></pre><p>The <code>App.swift</code> file contains the standard entry point for a Hummingbird application. The <code>Application+build.swift</code> file includes the Hummingbird app configuration using the WebSocket connection manager. The <code>ConnectionManager</code> is responsible for managing WebSocket connections. The <code>public/chat.html</code> file contains client-side JavaScript code to demonstrate a WebSocket connection.</p><p>To add WebSocket support to a Hummingbird-based Swift package, simply include the Hummingbird Websocket library as a dependency in your <code>Package.swift</code> file..</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xc'>// swift-tools-version:5.10</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>PackageDescription</span><span class='newline'>

</span><span class='xk'>let</span> <span class='xv'>package</span> = <span class='xv'>Package</span>(<span class='newline'>
</span>    <span class='xv'>name</span>: <span class='xs'>"websocket-chat"</span>,<span class='newline'>
</span>    <span class='xv'>platforms</span>: [<span class='newline'>
</span>        .<span class='xv'>macOS</span>(.<span class='xv'>v14</span>),<span class='newline'>
</span>    ],<span class='newline'>
</span>    <span class='xv'>products</span>: [<span class='newline'>
</span>        .<span class='xv'>executable</span>(<span class='xv'>name</span>: <span class='xs'>"App"</span>, <span class='xv'>targets</span>: [<span class='xs'>"App"</span>]),<span class='newline'>
</span>    ],<span class='newline'>
</span>    <span class='xv'>dependencies</span>: [<span class='newline'>
</span>        .<span class='xv'>package</span>(<span class='xv'>url</span>: <span class='xs'>"https://github.com/hummingbird-project/hummingbird.git"</span>, <span class='xv'>from</span>: <span class='xs'>"2.0.0-rc.1"</span>),<span class='newline'>
</span>        .<span class='xv'>package</span>(<span class='xv'>url</span>: <span class='xs'>"https://github.com/hummingbird-project/hummingbird-websocket.git"</span>, <span class='xv'>from</span>: <span class='xs'>"2.0.0-beta.5"</span>),<span class='newline'>
</span>        .<span class='xv'>package</span>(<span class='xv'>url</span>: <span class='xs'>"https://github.com/apple/swift-argument-parser.git"</span>, <span class='xv'>from</span>: <span class='xs'>"1.4.0"</span>),<span class='newline'>
</span>    ],<span class='newline'>
</span>    <span class='xv'>targets</span>: [<span class='newline'>
</span>        .<span class='xv'>executableTarget</span>(<span class='newline'>
</span>            <span class='xv'>name</span>: <span class='xs'>"App"</span>,<span class='newline'>
</span>            <span class='xv'>dependencies</span>: [<span class='newline'>
</span>                .<span class='xv'>product</span>(<span class='xv'>name</span>: <span class='xs'>"ArgumentParser"</span>, <span class='xv'>package</span>: <span class='xs'>"swift-argument-parser"</span>),<span class='newline'>
</span>                .<span class='xv'>product</span>(<span class='xv'>name</span>: <span class='xs'>"Hummingbird"</span>, <span class='xv'>package</span>: <span class='xs'>"hummingbird"</span>),<span class='newline'>
</span>                .<span class='xv'>product</span>(<span class='xv'>name</span>: <span class='xs'>"HummingbirdWebSocket"</span>, <span class='xv'>package</span>: <span class='xs'>"hummingbird-websocket"</span>),<span class='newline'>
</span>                .<span class='xv'>product</span>(<span class='xv'>name</span>: <span class='xs'>"HummingbirdWSCompression"</span>, <span class='xv'>package</span>: <span class='xs'>"hummingbird-websocket"</span>),<span class='newline'>
</span>            ]<span class='newline'>
</span>        )<span class='newline'>
</span>    ]<span class='newline'>
</span>)</code></pre><p>The <code>App.swift</code> file is the main entry point for a Hummingbird application using the <code><a href='https://swiftinit.org/hist/swift-argument-parser:1.4.0/argumentparser' target='_blank' rel='external'>ArgumentParser</a></code> library.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xc'>// 1.</span><span class='newline'>
</span><span class='xk'>protocol</span> <span class='xt'>AppArguments</span> {<span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>hostname</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/string' target='_blank' rel='external'>String</a> { <span class='xv'>get</span> }<span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>port</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/int' target='_blank' rel='external'>Int</a> { <span class='xv'>get</span> }<span class='newline'>
</span>}<span class='newline'>

</span><span class='xc'>// 2.</span><span class='newline'>
</span><span class='xa'>@main</span><span class='newline'>
</span><span class='xk'>struct</span> <span class='xt'>HummingbirdArguments</span>: <span class='xt'>AppArguments</span>, <a class='xt' href='https://swiftinit.org/hist/swift-argument-parser:1.4.0/argumentparser/asyncparsablecommand' target='_blank' rel='external'>AsyncParsableCommand</a> {<span class='newline'>
</span>    <span class='xa'>@Option</span>(<span class='xv'>name</span>: .<a class='xv' href='https://swiftinit.org/hist/swift-argument-parser:1.4.0/argumentparser/namespecification.shortandlong' target='_blank' rel='external'>shortAndLong</a>)<span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>hostname</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/string' target='_blank' rel='external'>String</a> = <span class='xs'>"127.0.0.1"</span><span class='newline'>

</span>    <span class='xa'>@Option</span>(<span class='xv'>name</span>: .<a class='xv' href='https://swiftinit.org/hist/swift-argument-parser:1.4.0/argumentparser/namespecification.shortandlong' target='_blank' rel='external'>shortAndLong</a>)<span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>port</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/int' target='_blank' rel='external'>Int</a> = <span class='xn'>8080</span><span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>run</span>() <span class='xk'>async</span> <span class='xk'>throws</span> {<span class='newline'>
</span>        <span class='xc'>// 3.</span><span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>app</span> = <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>buildApplication</span>(<span class='xk'>self</span>)<span class='newline'>
</span>        <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>app</span>.<span class='xv'>runService</span>()<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/site/blob/main/Snippets/websockets.swift#L187' target='_blank' class='source github'><span class='file'>websockets.swift</span>:<span class='line'>187</span></a><ol><li><p>The <code>AppArguments</code> protocol defines hostname and port properties.</p></li><li><p>The <code>HummingbirdArguments</code> structure is the main entry point, using <code><a href='https://swiftinit.org/hist/swift-argument-parser:1.4.0/argumentparser/asyncparsablecommand' target='_blank' rel='external'>AsyncParsableCommand</a></code>, and sets command-line options.</p></li><li><p>The run function builds the Hummingbird application and starts the server as a service.</p></li></ol><p>The code inside the <code>Application+build.swift</code> file sets up a Hummingbird application configured for WebSocket communication. It defines a function buildApplication that takes command-line arguments for hostname and port, initializes a logger, and sets up routers with middlewares for logging and file handling. It creates a <code>ConnectionManager</code> for managing WebSocket connections and configures the WebSocket router to handle chat connections, upgrading the connection if a username is provided:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>func</span> <span class='xv'>buildApplication</span>(<span class='newline'>
</span>    _ <span class='xv'>arguments</span>: <span class='xk'>some</span> <span class='xt'>AppArguments</span><span class='newline'>
</span>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xk'>some</span> <span class='xt'>ApplicationProtocol</span> {<span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>logger</span> = <a class='xt' href='https://swiftinit.org/docs/swift-log/logging/logger' target='_blank' rel='external'>Logger</a>(<span class='xv'>label</span>: <span class='xs'>"WebSocketChat"</span>)<span class='newline'>
</span>    <span class='xv'>logger</span>.<a class='xv' href='https://swiftinit.org/docs/swift-log/logging/logger.loglevel' target='_blank' rel='external'>logLevel</a> = .<a class='xv' href='https://swiftinit.org/docs/swift-log/logging/logger/level.trace' target='_blank' rel='external'>trace</a><span class='newline'>

</span>    <span class='xc'>// 1.</span><span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>router</span> = <span class='xt'>Router</span>()<span class='newline'>
</span>    <span class='xv'>router</span>.<span class='xv'>middlewares</span>.<span class='xv'>add</span>(<span class='xt'>LogRequestsMiddleware</span>(.<a class='xv' href='https://swiftinit.org/docs/swift-log/logging/logger/level.debug' target='_blank' rel='external'>debug</a>))<span class='newline'>
</span>    <span class='xv'>router</span>.<span class='xv'>middlewares</span>.<span class='xv'>add</span>(<span class='xt'>FileMiddleware</span>(<span class='xv'>logger</span>: <span class='xv'>logger</span>))<span class='newline'>

</span>    <span class='xc'>// 2.</span><span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>connectionManager</span> = <span class='xt'>ConnectionManager</span>(<span class='xv'>logger</span>: <span class='xv'>logger</span>)<span class='newline'>
</span>    <span class='xc'>// 3.</span><span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>wsRouter</span> = <span class='xt'>Router</span>(<span class='xv'>context</span>: <span class='xt'>BasicWebSocketRequestContext</span>.<span class='xk'>self</span>)<span class='newline'>
</span>    <span class='xv'>wsRouter</span>.<span class='xv'>middlewares</span>.<span class='xv'>add</span>(<span class='xt'>LogRequestsMiddleware</span>(.<a class='xv' href='https://swiftinit.org/docs/swift-log/logging/logger/level.debug' target='_blank' rel='external'>debug</a>))<span class='newline'>
</span>    <span class='xc'>// 4.</span><span class='newline'>
</span>    <span class='xv'>wsRouter</span>.<span class='xv'>ws</span>(<span class='xs'>"chat"</span>) { <span class='xv'>request</span>, _ <span class='xk'>in</span><span class='newline'>
</span>        <span class='xk'>guard</span> <span class='xv'>request</span>.<span class='xv'>uri</span>.<span class='xv'>queryParameters</span><a>[</a><a class='xs' href='https://swiftinit.org/docs/swift/swift/substring.init(stringliteral:)' target='_blank' rel='external'>"username"</a>] <a class='xv' href='https://swiftinit.org/docs/swift/swift/optional.!=(_:_:)?hash=7MFJN' target='_blank' rel='external'>!=</a> <span class='xk'>nil</span> <span class='xk'>else</span> {<span class='newline'>
</span>            <span class='xk'>return</span> .<span class='xv'>dontUpgrade</span><span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='xk'>return</span> .<span class='xv'>upgrade</span>([:])<span class='newline'>
</span>    <span class='xc'>// 5.</span><span class='newline'>
</span>    } <span class='xv'>onUpgrade</span>: { <span class='xv'>inbound</span>, <span class='xv'>outbound</span>, <span class='xv'>context</span> <span class='xk'>in</span><span class='newline'>
</span>        <span class='xk'>guard</span> <span class='xk'>let</span> <span class='xv'>name</span> = <span class='xv'>context</span>.<span class='xv'>request</span>.<span class='xv'>uri</span>.<span class='xv'>queryParameters</span><a>[</a><a class='xs' href='https://swiftinit.org/docs/swift/swift/substring.init(stringliteral:)' target='_blank' rel='external'>"username"</a>] <span class='xk'>else</span> {<span class='newline'>
</span>            <span class='xk'>return</span><span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>outputStream</span> = <span class='xv'>connectionManager</span>.<span class='xv'>addUser</span>(<span class='newline'>
</span>            <span class='xv'>name</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/string' target='_blank' rel='external'>String</a>(<span class='xv'>name</span>),<span class='newline'>
</span>            <span class='xv'>inbound</span>: <span class='xv'>inbound</span>,<span class='newline'>
</span>            <span class='xv'>outbound</span>: <span class='xv'>outbound</span><span class='newline'>
</span>        )<span class='newline'>
</span>        <span class='xk'>for</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>output</span> <span class='xk'>in</span> <span class='xv'>outputStream</span> {<span class='newline'>
</span>            <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>outbound</span>.<span class='xv'>write</span>(<span class='xv'>output</span>)<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xc'>// ...</span><span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/site/blob/main/Snippets/websockets.swift#L129' target='_blank' class='source github'><span class='file'>websockets.swift</span>:<span class='line'>129</span></a><ol><li><p>A <code>Router</code> instance is created, and middlewares for logging requests and serving files are added to it.</p></li><li><p>A <code>ConnectionManager</code> instance is created with a logger for managing WebSocket connections.</p></li><li><p>A separate <code>Router</code> instance is created specifically for handling and logging WebSocket requests.</p></li><li><p>A WebSocket route is set up for the <code>/chat</code> path, checking for a username query parameter for WebSocket upgrades.</p></li><li><p>On upgrade, the connection manager handles WebSocket users and writes the output stream to the outbound channel.</p></li></ol><p>The application is configured to use HTTP with WebSocket upgrades and includes WebSocket compression. Finally, the application is returned with the necessary services added:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>import</span> <span class='xv'>ArgumentParser</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>AsyncAlgorithms</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>Foundation</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>Hummingbird</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>HummingbirdWebSocket</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>HummingbirdWSCompression</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>Logging</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>ServiceLifecycle</span><span class='newline'>

</span><span class='xk'>func</span> <span class='xv'>buildApplication</span>(<span class='newline'>
</span>    _ <span class='xv'>arguments</span>: <span class='xk'>some</span> <span class='xt'>AppArguments</span><span class='newline'>
</span>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xk'>some</span> <span class='xt'>ApplicationProtocol</span> {<span class='newline'>
</span>    <span class='xc'>// ... </span><span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>connectionManager</span> = <span class='xt'>ConnectionManager</span>(<span class='xv'>logger</span>: <span class='xv'>logger</span>)<span class='newline'>
</span>    <span class='xc'>// ...</span><span class='newline'>
</span>    <span class='xc'>// 1.</span><span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>app</span> = <span class='xt'>Application</span>(<span class='newline'>
</span>        <span class='xv'>router</span>: <span class='xv'>router</span>,<span class='newline'>
</span>        <span class='xv'>server</span>: .<span class='xv'>http1WebSocketUpgrade</span>(<span class='newline'>
</span>            <span class='xv'>webSocketRouter</span>: <span class='xv'>wsRouter</span>,<span class='newline'>
</span>            <span class='xv'>configuration</span>: .<span class='xv'>init</span>(<span class='xv'>extensions</span>: [.<span class='xv'>perMessageDeflate</span>()])<span class='newline'>
</span>        ),<span class='newline'>
</span>        <span class='xv'>configuration</span>: .<span class='xv'>init</span>(<span class='newline'>
</span>            <span class='xv'>address</span>: .<span class='xv'>hostname</span>(<span class='xv'>arguments</span>.<span class='xv'>hostname</span>, <span class='xv'>port</span>: <span class='xv'>arguments</span>.<span class='xv'>port</span>)<span class='newline'>
</span>        ),<span class='newline'>
</span>        <span class='xv'>logger</span>: <span class='xv'>logger</span><span class='newline'>
</span>    )<span class='newline'>
</span>    <span class='xc'>// 2.</span><span class='newline'>
</span>    <span class='xv'>app</span>.<span class='xv'>addServices</span>(<span class='xv'>connectionManager</span>)<span class='newline'>
</span>    <span class='xk'>return</span> <span class='xv'>app</span><span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/site/blob/main/Snippets/websockets-app.swift#L79' target='_blank' class='source github'><span class='file'>websockets-app.swift</span>:<span class='line'>79</span></a><ol><li><p>An <code>Application</code> instance is created with the previously configured routers for both HTTP and WebSocket requests.</p></li><li><p>The <code>ConnectionManager</code> is added as a service to the application before returning it.</p></li></ol><p>The <code>ConnectionManager</code> struct manages WebSocket connections, allowing users to join, send messages, and leave the chat, using an <code>AsyncStream</code> for connection handling and Actor for managing outbound connections:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>import</span> <span class='xv'>ArgumentParser</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>AsyncAlgorithms</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>Foundation</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>Hummingbird</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>HummingbirdWebSocket</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>HummingbirdWSCompression</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>Logging</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>ServiceLifecycle</span><span class='newline'>

</span><span class='xc'>// 1.</span><span class='newline'>
</span><span class='xk'>struct</span> <span class='xt'>ConnectionManager</span>: <a class='xt' href='https://swiftinit.org/hist/swift-service-lifecycle:2.6.0/servicelifecycle/service' target='_blank' rel='external'>Service</a> {<span class='newline'>

</span>    <span class='xc'>// 2.</span><span class='newline'>
</span>    <span class='xk'>typealias</span> <span class='xt'>OutputStream</span> = <a class='xt' href='https://swiftinit.org/docs/swift-async-algorithms/asyncalgorithms/asyncchannel' target='_blank' rel='external'>AsyncChannel</a>&lt;<span class='xt'>WebSocketOutboundWriter</span>.<span class='xt'>OutboundFrame</span>&gt;<span class='newline'>

</span>    <span class='xc'>// 3.</span><span class='newline'>
</span>    <span class='xk'>struct</span> <span class='xt'>Connection</span> {<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>name</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/string' target='_blank' rel='external'>String</a><span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>inbound</span>: <span class='xt'>WebSocketInboundStream</span><span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>outbound</span>: <span class='xt'>OutputStream</span><span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xc'>// 4.</span><span class='newline'>
</span>    <span class='xk'>actor</span> <span class='xt'>OutboundConnections</span> {<span class='newline'>
</span>        <span class='newline'>
</span>        <span class='xk'>var</span> <span class='xv'>outboundWriters</span>: [<a class='xt' href='https://swiftinit.org/docs/swift/swift/string' target='_blank' rel='external'>String</a>: <span class='xt'>OutputStream</span>]<span class='newline'>

</span>        <span class='xk'>init</span>() {<span class='newline'>
</span>            <span class='xk'>self</span>.<span class='xv'>outboundWriters</span> = [:]<span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='newline'>
</span>        <span class='xk'>func</span> <span class='xv'>send</span>(_ <span class='xv'>output</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/string' target='_blank' rel='external'>String</a>) <span class='xk'>async</span> {<span class='newline'>
</span>            <span class='xk'>for</span> <span class='xv'>outbound</span> <span class='xk'>in</span> <span class='xv'>outboundWriters</span>.<a class='xv' href='https://swiftinit.org/docs/swift/swift/dictionary.values' target='_blank' rel='external'>values</a> {<span class='newline'>
</span>                <span class='xk'>await</span> <span class='xv'>outbound</span>.<a class='xv' href='https://swiftinit.org/docs/swift-async-algorithms/asyncalgorithms/asyncchannel.send(_:)' target='_blank' rel='external'>send</a>(.<span class='xv'>text</span>(<span class='xv'>output</span>))<span class='newline'>
</span>            }<span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='newline'>
</span>        <span class='xk'>func</span> <span class='xv'>add</span>(<span class='xv'>name</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/string' target='_blank' rel='external'>String</a>, <span class='xv'>outbound</span>: <span class='xt'>OutputStream</span>) <span class='xk'>async</span> {<span class='newline'>
</span>            <span class='xv'>outboundWriters</span><a href='https://swiftinit.org/docs/swift/swift/dictionary.subscript(_:)?hash=8RFQL' target='_blank' rel='external'>[</a><span class='xv'>name</span>] = <span class='xv'>outbound</span><span class='newline'>
</span>            <span class='xk'>await</span> <span class='xv'>send</span>(<a class='xs' href='https://swiftinit.org/docs/swift/swift/string.init(stringinterpolation:)' target='_blank' rel='external'>"</a>\(<span class='xv'>name</span>)<span class='xs'> joined"</span>)<span class='newline'>
</span>        }<span class='newline'>

</span>        <span class='xk'>func</span> <span class='xv'>remove</span>(<span class='xv'>name</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/string' target='_blank' rel='external'>String</a>) <span class='xk'>async</span> {<span class='newline'>
</span>            <span class='xv'>outboundWriters</span><a href='https://swiftinit.org/docs/swift/swift/dictionary.subscript(_:)?hash=8RFQL' target='_blank' rel='external'>[</a><span class='xv'>name</span>] = <span class='xk'>nil</span><span class='newline'>
</span>            <span class='xk'>await</span> <span class='xv'>send</span>(<a class='xs' href='https://swiftinit.org/docs/swift/swift/string.init(stringinterpolation:)' target='_blank' rel='external'>"</a>\(<span class='xv'>name</span>)<span class='xs'> left"</span>)<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/site/blob/main/Snippets/websockets-connection-manager-types.swift#L51' target='_blank' class='source github'><span class='file'>websockets-connection-manager-types.swift</span>:<span class='line'>51</span></a><ol><li><p>The <code>ConnectionManager</code> implements the <code><a href='https://swiftinit.org/hist/swift-service-lifecycle:2.6.0/servicelifecycle/service' target='_blank' rel='external'>Service</a></code> protocol to manage WebSocket connections and ensure graceful shutdown.</p></li><li><p><code><a href='https://swiftinit.org/docs/swift/foundation/outputstream' target='_blank' rel='external'>OutputStream</a></code> is defined as an <code><a href='https://swiftinit.org/docs/swift-async-algorithms/asyncalgorithms/asyncchannel' target='_blank' rel='external'>AsyncChannel</a></code> for sending WebSocket outbound frames.</p></li><li><p>The <code>Connection</code> struct contains details about each WebSocket connection, including the username, inbound stream, and outbound stream.</p></li><li><p>The <code>OutboundConnections</code> actor manages a dictionary of outbound writers to broadcast messages to all connections.</p></li></ol><p>The <code>addUser</code> function creates a <code>Connection</code> object with a given name and WebSocket streams, yields this connection, and returns a new <code><a href='https://swiftinit.org/docs/swift/foundation/outputstream' target='_blank' rel='external'>OutputStream</a></code>:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>import</span> <span class='xv'>ArgumentParser</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>AsyncAlgorithms</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>Foundation</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>Hummingbird</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>HummingbirdWebSocket</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>HummingbirdWSCompression</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>Logging</span><span class='newline'>
</span><span class='xk'>import</span> <span class='xv'>ServiceLifecycle</span><span class='newline'>

</span><span class='xk'>struct</span> <span class='xt'>ConnectionManager</span>: <a class='xt' href='https://swiftinit.org/hist/swift-service-lifecycle:2.6.0/servicelifecycle/service' target='_blank' rel='external'>Service</a> {<span class='newline'>

</span>    <span class='xc'>// ...</span><span class='newline'>
</span>    <span class='xk'>func</span> <span class='xv'>addUser</span>(<span class='newline'>
</span>        <span class='xv'>name</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/string' target='_blank' rel='external'>String</a>,<span class='newline'>
</span>        <span class='xv'>inbound</span>: <span class='xt'>WebSocketInboundStream</span>,<span class='newline'>
</span>        <span class='xv'>outbound</span>: <span class='xt'>WebSocketOutboundWriter</span><span class='newline'>
</span>    ) -&gt; <span class='xt'>OutputStream</span> {<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>outputStream</span> = <span class='xt'>OutputStream</span>()<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>connection</span> = <span class='xt'>Connection</span>(<span class='newline'>
</span>            <span class='xv'>name</span>: <span class='xv'>name</span>,<span class='newline'>
</span>            <span class='xv'>inbound</span>: <span class='xv'>inbound</span>,<span class='newline'>
</span>            <span class='xv'>outbound</span>: <span class='xv'>outputStream</span><span class='newline'>
</span>        )<span class='newline'>
</span>        <span class='xv'>connectionContinuation</span>.<a class='xv' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream/continuation.yield(_:)' target='_blank' rel='external'>yield</a>(<span class='xv'>connection</span>)<span class='newline'>
</span>        <span class='xk'>return</span> <span class='xv'>outputStream</span><span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/site/blob/main/Snippets/websockets-connection-manager-add-user.swift#L59' target='_blank' class='source github'><span class='file'>websockets-connection-manager-add-user.swift</span>:<span class='line'>59</span></a><p>The <code>init(logger:)</code> method creates an asynchronous stream for <code>Connection</code> objects along with a logger, and the <code>run</code> function asynchronously handles connections by logging their addition, processing inbound messages, sending outbound messages, and logging their removal, with graceful shutdown support:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>struct</span> <span class='xt'>ConnectionManager</span>: <a class='xt' href='https://swiftinit.org/hist/swift-service-lifecycle:2.6.0/servicelifecycle/service' target='_blank' rel='external'>Service</a> {<span class='newline'>

</span>    <span class='xc'>// ...</span><span class='newline'>

</span>    <span class='xk'>let</span> <span class='xv'>connectionStream</span>: <a class='xt' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream' target='_blank' rel='external'>AsyncStream</a>&lt;<span class='xt'>Connection</span>&gt;<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>connectionContinuation</span>: <a class='xt' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream' target='_blank' rel='external'>AsyncStream</a>&lt;<span class='xt'>Connection</span>&gt;.<a class='xt' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream/continuation' target='_blank' rel='external'>Continuation</a><span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>logger</span>: <a class='xt' href='https://swiftinit.org/docs/swift-log/logging/logger' target='_blank' rel='external'>Logger</a><span class='newline'>

</span>    <span class='xk'>init</span>(<span class='xv'>logger</span>: <a class='xt' href='https://swiftinit.org/docs/swift-log/logging/logger' target='_blank' rel='external'>Logger</a>) {<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>stream</span> = <a class='xt' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream' target='_blank' rel='external'>AsyncStream</a>&lt;<span class='xt'>Connection</span>&gt;.<a class='xv' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream.makestream(of:bufferingpolicy:)' target='_blank' rel='external'>makeStream</a>()<span class='newline'>
</span>        <span class='xk'>self</span>.<span class='xv'>connectionStream</span> = <span class='xv'>stream</span>.<span class='xv'>stream</span><span class='newline'>
</span>        <span class='xk'>self</span>.<span class='xv'>connectionContinuation</span> = <span class='xv'>stream</span>.<span class='xv'>continuation</span><span class='newline'>
</span>        <span class='xk'>self</span>.<span class='xv'>logger</span> = <span class='xv'>logger</span><span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>run</span>() <span class='xk'>async</span> {<span class='newline'>
</span>        <span class='xk'>await</span> <a class='xv' href='https://swiftinit.org/hist/swift-service-lifecycle:2.6.0/servicelifecycle.withgracefulshutdownhandler(operation:ongracefulshutdown:)' target='_blank' rel='external'>withGracefulShutdownHandler</a> {<span class='newline'>
</span>            <span class='xk'>await</span> <a class='xv' href='https://swiftinit.org/docs/swift/_concurrency.withdiscardingtaskgroup(returning:body:)' target='_blank' rel='external'>withDiscardingTaskGroup</a> { <span class='xv'>group</span> <span class='xk'>in</span><span class='newline'>
</span>                <span class='xk'>let</span> <span class='xv'>outboundCounnections</span> = <span class='xt'>OutboundConnections</span>()<span class='newline'>
</span>                <span class='xc'>// 1.</span><span class='newline'>
</span>                <span class='xk'>for</span> <span class='xk'>await</span> <span class='xv'>connection</span> <span class='xk'>in</span> <span class='xv'>connectionStream</span> {<span class='newline'>
</span>                    <span class='xv'>group</span>.<a class='xv' href='https://swiftinit.org/docs/swift/_concurrency/discardingtaskgroup.addtask(operation:)' target='_blank' rel='external'>addTask</a> {<span class='newline'>
</span>                        <span class='xv'>logger</span>.<a class='xv' href='https://swiftinit.org/docs/swift-log/logging/logger.info(_:metadata:file:function:line:)' target='_blank' rel='external'>info</a>(<a class='xs' href='https://swiftinit.org/docs/swift-log/logging/logger/message.init(stringliteral:)' target='_blank' rel='external'>"add connection"</a>, <span class='xv'>metadata</span>: [<span class='newline'>
</span>                            <span class='xs'>"name"</span>: .<a class='xv' href='https://swiftinit.org/docs/swift-log/logging/logger/metadatavalue.string(_:)' target='_blank' rel='external'>string</a>(<span class='xv'>connection</span>.<span class='xv'>name</span>)<span class='newline'>
</span>                        ])<span class='newline'>
</span>                        <span class='xc'>// 2.</span><span class='newline'>
</span>                        <span class='xk'>await</span> <span class='xv'>outboundCounnections</span>.<span class='xv'>add</span>(<span class='newline'>
</span>                            <span class='xv'>name</span>: <span class='xv'>connection</span>.<span class='xv'>name</span>,<span class='newline'>
</span>                            <span class='xv'>outbound</span>: <span class='xv'>connection</span>.<span class='xv'>outbound</span><span class='newline'>
</span>                        )<span class='newline'>

</span>                        <span class='xk'>do</span> {<span class='newline'>
</span>                            <span class='xc'>// 3.</span><span class='newline'>
</span>                            <span class='xk'>for</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>input</span> <span class='xk'>in</span> <span class='xv'>connection</span>.<span class='xv'>inbound</span>.<span class='xv'>messages</span>(<span class='newline'>
</span>                                <span class='xv'>maxSize</span>: <span class='xn'>1_000_000</span><span class='newline'>
</span>                            ) {<span class='newline'>
</span>                                <span class='xk'>guard</span> <span class='xk'>case</span> .<span class='xv'>text</span>(<span class='xk'>let</span> <span class='xv'>text</span>) = <span class='xv'>input</span> <span class='xk'>else</span> {<span class='newline'>
</span>                                    <span class='xk'>continue</span><span class='newline'>
</span>                                }<span class='newline'>
</span>                                <span class='xk'>let</span> <span class='xv'>output</span> = <a class='xs' href='https://swiftinit.org/docs/swift/swift/string.init(stringinterpolation:)' target='_blank' rel='external'>"[</a>\(<span class='xv'>connection</span>.<span class='xv'>name</span>)<span class='xs'>]: </span>\(<span class='xv'>text</span>)<span class='xs'>"</span><span class='newline'>
</span>                                <span class='xv'>logger</span>.<a class='xv' href='https://swiftinit.org/docs/swift-log/logging/logger.debug(_:metadata:file:function:line:)' target='_blank' rel='external'>debug</a>(<a class='xs' href='https://swiftinit.org/docs/swift-log/logging/logger/message.init(stringliteral:)' target='_blank' rel='external'>"Output"</a>, <span class='xv'>metadata</span>: [<span class='newline'>
</span>                                    <span class='xs'>"message"</span>: .<a class='xv' href='https://swiftinit.org/docs/swift-log/logging/logger/metadatavalue.string(_:)' target='_blank' rel='external'>string</a>(<span class='xv'>output</span>)<span class='newline'>
</span>                                ])<span class='newline'>
</span>                                <span class='xc'>// 4.</span><span class='newline'>
</span>                                <span class='xk'>await</span> <span class='xv'>outboundCounnections</span>.<span class='xv'>send</span>(<span class='xv'>output</span>)<span class='newline'>
</span>                            }<span class='newline'>
</span>                        } <span class='xk'>catch</span> {}<span class='newline'>

</span>                        <span class='xv'>logger</span>.<a class='xv' href='https://swiftinit.org/docs/swift-log/logging/logger.info(_:metadata:file:function:line:)' target='_blank' rel='external'>info</a>(<a class='xs' href='https://swiftinit.org/docs/swift-log/logging/logger/message.init(stringliteral:)' target='_blank' rel='external'>"remove connection"</a>, <span class='xv'>metadata</span>: [<span class='newline'>
</span>                            <span class='xs'>"name"</span>: .<a class='xv' href='https://swiftinit.org/docs/swift-log/logging/logger/metadatavalue.string(_:)' target='_blank' rel='external'>string</a>(<span class='xv'>connection</span>.<span class='xv'>name</span>)<span class='newline'>
</span>                        ])<span class='newline'>
</span>                        <span class='xc'>// 5.</span><span class='newline'>
</span>                        <span class='xk'>await</span> <span class='xv'>outboundCounnections</span>.<span class='xv'>remove</span>(<span class='xv'>name</span>: <span class='xv'>connection</span>.<span class='xv'>name</span>)<span class='newline'>
</span>                        <span class='xv'>connection</span>.<span class='xv'>outbound</span>.<a class='xv' href='https://swiftinit.org/docs/swift-async-algorithms/asyncalgorithms/asyncchannel.finish' target='_blank' rel='external'>finish</a>()<span class='newline'>
</span>                    }<span class='newline'>
</span>                }<span class='newline'>
</span>                <span class='xv'>group</span>.<a class='xv' href='https://swiftinit.org/docs/swift/_concurrency/discardingtaskgroup.cancelall' target='_blank' rel='external'>cancelAll</a>()<span class='newline'>
</span>            }<span class='newline'>
</span>        } <span class='xv'>onGracefulShutdown</span>: {<span class='newline'>
</span>            <span class='xv'>connectionContinuation</span>.<a class='xv' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream/continuation.finish' target='_blank' rel='external'>finish</a>()<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/site/blob/main/Snippets/websockets.swift#L10' target='_blank' class='source github'><span class='file'>websockets.swift</span>:<span class='line'>10</span></a><ol><li><p>The <code>run</code> function iterates through the <code>connectionStream</code> asynchronously to handle incoming connections and messages.</p></li><li><p>For each connection, a task is added to the group to manage the connection and broadcast the “joined” message.</p></li><li><p>The task listens for incoming messages, processing text messages to broadcast to all connections.</p></li><li><p>Each received text message is broadcast to all outbound connections by calling <code>send</code>.</p></li><li><p>Upon connection termination, the connection is removed, a “left” message is broadcast, and the outbound stream is finished.</p></li></ol><p>Make sure the <a href='https://theswiftdev.com/custom-working-directory-in-xcode/' target='_blank' rel='external nofollow noopener ugc'>custom working directory</a> is set to the root folder before starting the app. Client communication with the WebSocket server can be established using the <code>ws://localhost:8080/chat</code> endpoint.</p><p>Execute the app and open a web browser to navigate to the <a href='https://websocketman.com/' target='_blank' rel='external nofollow noopener ugc'>WebSocket Tester Tool</a> website. To initiate a chat connection, input the following URL into the designated field:</p><pre class='snippet'><code><span class='newline'></span>ws://localhost:8080/chat?username=Tib</code></pre><p>The <code>username</code> parameter can be modified as needed. Press the <em>Connect</em> button to add a new user to the chat room. Upon connection, messages can be sent as the user by entering a custom message and clicking the <em>Send Message</em> button. Multiple windows of the WebSocket Tester Tool can be opened to add additional users.</p><h2 id='Conclusion'><a href='#Conclusion'>Conclusion</a></h2><p>This article demonstrated how to use WebSockets with the Hummingbird framework to build a real-time chat application in Swift. For a similar guide on the Vapor web framework, check out <a href='https://theswiftdev.com/websockets-for-beginners-using-vapor-4-and-vanilla-javascript/' target='_blank' rel='external nofollow noopener ugc'>this article</a>. Hummingbird 2 leverages modern Swift concurrency features for handling WebSocket connections, offering a significant advantage over other frameworks. For more information on Swift concurrency, dive into our additional articles about <a href='https://swiftonserver.com/getting-started-with-structured-concurrency-in-swift/' target='_blank' rel='external nofollow noopener ugc'>structured concurrency</a>.</p></section><div style='display: none;' id='ss:tooltips'><a href='/docs/swift/_concurrency/taskgroup'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>TaskGroup</span>&lt;<span class='xu'>ChildTaskResult</span>&gt; <span class='xk'>where</span> <span class='xt'>ChildTaskResult</span> : <span class='xt'>Sendable</span></code></pre><p>A group that contains dynamically created child tasks.</p></a><a href='/docs/swift/_concurrency/asyncsequence'><pre><code><span class='xa'>@rethrows</span> <span class='xk'>protocol</span> <span class='xv'>AsyncSequence</span></code></pre><p>A type that provides asynchronous, sequential, iterated access to its elements.</p></a><a href='/hist/swift-argument-parser:1.4.0/argumentparser'><pre><code><span class='xk'>import</span> <span class='xv'>ArgumentParser</span></code></pre><p>Straightforward, type-safe argument parsing for Swift.</p></a><a href='/docs/swift/swift/string'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>String</span></code></pre><p>A Unicode string value that is a collection of characters.</p></a><a href='/docs/swift/swift/int'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>Int</span></code></pre><p>A signed integer value type.</p></a><a href='/hist/swift-argument-parser:1.4.0/argumentparser/asyncparsablecommand'><pre><code><span class='xk'>protocol</span> <span class='xv'>AsyncParsableCommand</span> : <span class='xt'>ParsableCommand</span></code></pre><p>A type that can be executed asynchronously, as part of a nested tree of commands.</p></a><a href='/hist/swift-argument-parser:1.4.0/argumentparser/namespecification.shortandlong'><pre><code><span class='xk'>static</span> <span class='xk'>var</span> <span class='xv'>shortAndLong</span>: <span class='xt'>NameSpecification</span> { <span class='xk'>get</span> }</code></pre><p>Combine the <code>.short</code> and <code>.long</code> specifications to allow both long and short labels.</p></a><a href='/docs/swift-log/logging/logger'><pre><code><span class='xk'>struct</span> <span class='xv'>Logger</span></code></pre><p>A <code>Logger</code> is the central type in <code>SwiftLog</code>. Its central function is to emit log messages using one of the methods corresponding to a log level.</p></a><a href='/docs/swift-log/logging/logger.loglevel'><pre><code><span class='xk'>var</span> <span class='xv'>logLevel</span>: <span class='xt'>Logger</span>.<span class='xt'>Level</span> { <span class='xk'>get</span> <span class='xk'>set</span> }</code></pre><p>Get or set the log level configured for this <code>Logger</code>.</p></a><a href='/docs/swift-log/logging/logger/level.trace'><pre><code><span class='xk'>case</span> <span class='xv'>trace</span></code></pre><p>Appropriate for messages that contain information normally of use only when tracing the execution of a program.</p></a><a href='/docs/swift-log/logging/logger/level.debug'><pre><code><span class='xk'>case</span> <span class='xv'>debug</span></code></pre><p>Appropriate for messages that contain information normally of use only when debugging a program.</p></a><a href='/docs/swift/swift/substring.init(stringliteral:)'><pre><code><span class='xk'>init</span>(<span class='xi'></span><span class='xv'>stringLiteral</span> <span class='xb'>value</span>: <span class='xt'>String</span><wbr>)</code></pre></a><a href='/docs/swift/swift/optional.!=(_:_:)?hash=7MFJN'><pre><code><span class='xk'>static</span> <span class='xk'>func</span> <span class='xo'>!=</span> (<span class='xi'></span><span class='xv'>lhs</span>: <span class='xt'>Wrapped</span>?, <span class='xi'></span><span class='xv'>rhs</span>: <span class='xt'>_OptionalNilComparisonType</span><wbr>) -&gt; <span class='xt'>Bool</span></code></pre><p>Returns a Boolean value indicating whether the left-hand-side argument is not <code>nil</code>.</p></a><a href='/hist/swift-service-lifecycle:2.6.0/servicelifecycle/service'><pre><code><span class='xk'>protocol</span> <span class='xv'>Service</span> : <span class='xt'>Sendable</span></code></pre><p>This is the basic protocol that a service has to implement.</p></a><a href='/docs/swift-async-algorithms/asyncalgorithms/asyncchannel'><pre><code><span class='xk'>final</span> <span class='xk'>class</span> <span class='xv'>AsyncChannel</span>&lt;<span class='xu'>Element</span>&gt; <span class='xk'>where</span> <span class='xt'>Element</span> : <span class='xt'>Sendable</span></code></pre><p>A channel for sending elements from one task to another with back pressure.</p></a><a href='/docs/swift/swift/dictionary.values'><pre><code><span class='xk'>var</span> <span class='xv'>values</span>: <span class='xt'>Dictionary</span>&lt;<span class='xt'>Key</span>, <span class='xt'>Value</span>&gt;.<span class='xt'>Values</span> { <span class='xk'>get</span> <span class='xk'>set</span> }</code></pre><p>A collection containing just the values of the dictionary.</p></a><a href='/docs/swift-async-algorithms/asyncalgorithms/asyncchannel.send(_:)'><pre><code><span class='xk'>func</span> <span class='xv'>send</span>(<span class='xi'></span>_ <span class='xb'>element</span>: <span class='xt'>Element</span><wbr>) <span class='xk'>async</span></code></pre><p>Sends an element to an awaiting iteration. This function will resume when the next call to <code>next()</code> is made or when a call to <code>finish()</code> is made from another task. If the channel is already finished then this returns immediately. If the task is cancelled, this function will resume without sending the element. Other sending operations from other tasks will remain active.</p></a><a href='/docs/swift/swift/dictionary.subscript(_:)?hash=8RFQL'><pre><code><span class='xk'>subscript</span>(<span class='xi'></span><span class='xv'>key</span>: <span class='xt'>Key</span><wbr>) -&gt; <span class='xt'>Value</span>? { <span class='xk'>get</span> <span class='xk'>set</span> }</code></pre><p>Accesses the value associated with the given key for reading and writing.</p></a><a href='/docs/swift/swift/string.init(stringinterpolation:)'><pre><code><span class='xk'>init</span>(<span class='xi'></span><span class='xv'>stringInterpolation</span>: <span class='xt'>DefaultStringInterpolation</span><wbr>)</code></pre><p>Creates a new instance from an interpolated string literal.</p></a><a href='/docs/swift/foundation/outputstream'><pre><code><span class='xk'>class</span> <span class='xv'>OutputStream</span></code></pre></a><a href='/docs/swift/_concurrency/asyncstream/continuation.yield(_:)'><pre><code><span class='xa'>@discardableResult</span> <span class='xk'>func</span> <span class='xv'>yield</span>(<span class='xi'></span>_ <span class='xb'>value</span>: <span class='xt'>Element</span><wbr>) -&gt; <span class='xt'>AsyncStream</span>&lt;<span class='xt'>Element</span>&gt;.<span class='xt'>Continuation</span>.<span class='xt'>YieldResult</span></code></pre><p>Resume the task awaiting the next iteration point by having it return normally from its suspension point with a given element.</p></a><a href='/docs/swift/_concurrency/asyncstream'><pre><code><span class='xk'>struct</span> <span class='xv'>AsyncStream</span>&lt;<span class='xu'>Element</span>&gt;</code></pre><p>An asynchronous sequence generated from a closure that calls a continuation to produce new elements.</p></a><a href='/docs/swift/_concurrency/asyncstream/continuation'><pre><code><span class='xk'>struct</span> <span class='xv'>Continuation</span></code></pre><p>A mechanism to interface between synchronous code and an asynchronous stream.</p></a><a href='/docs/swift/_concurrency/asyncstream.makestream(of:bufferingpolicy:)'><pre><code><span class='xa'>@backDeployed</span>(<span class='xk'>before</span>: <span class='xk'>macOS</span> <span class='xn'>14</span>.<span class='xn'>0</span>, <span class='xk'>iOS</span> <span class='xn'>17</span>.<span class='xn'>0</span>, <span class='xk'>watchOS</span> <span class='xn'>10</span>.<span class='xn'>0</span>, <span class='xk'>tvOS</span> <span class='xn'>17</span>.<span class='xn'>0</span>)
<span class='xk'>static</span> <span class='xk'>func</span> <span class='xv'>makeStream</span>(<span class='xi'></span><span class='xv'>of</span> <span class='xb'>elementType</span>: <span class='xt'>Element</span>.<span class='xk'>Type</span> = <span class='xv'>Element</span>.<span class='xk'>self</span>, <span class='xi'></span><span class='xv'>bufferingPolicy</span> <span class='xb'>limit</span>: <span class='xt'>AsyncStream</span>&lt;<span class='xt'>Element</span>&gt;.<span class='xt'>Continuation</span>.<span class='xt'>BufferingPolicy</span> = .<span class='xv'>unbounded</span><wbr>) -&gt; (<span class='xv'>stream</span>: <span class='xt'>AsyncStream</span>&lt;<span class='xt'>Element</span>&gt;, <span class='xv'>continuation</span>: <span class='xt'>AsyncStream</span>&lt;<span class='xt'>Element</span>&gt;.<span class='xt'>Continuation</span>)</code></pre><p>Initializes a new <code>AsyncStream</code> and an <code>Continuation</code>.</p></a><a href='/hist/swift-service-lifecycle:2.6.0/servicelifecycle.withgracefulshutdownhandler(operation:ongracefulshutdown:)'><pre><code><span class='xk'>func</span> <span class='xv'>withGracefulShutdownHandler</span>&lt;<span class='xu'>T</span>&gt;(<span class='xi'></span><span class='xv'>operation</span>: () <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>T</span>, <span class='xi'></span><span class='xv'>onGracefulShutdown</span> <span class='xb'>handler</span>: <span class='xa'>@escaping</span> () -&gt; <span class='xt'>Void</span><wbr>) <span class='xk'>async</span> <span class='xk'>rethrows</span> -&gt; <span class='xt'>T</span></code></pre><p>Execute an operation with a graceful shutdown handler that’s immediately invoked if the current task is shutting down gracefully.</p></a><a href='/docs/swift/_concurrency.withdiscardingtaskgroup(returning:body:)'><pre><code><span class='xk'>func</span> <span class='xv'>withDiscardingTaskGroup</span>&lt;<span class='xu'>GroupResult</span>&gt;(<span class='xi'></span><span class='xv'>returning</span> <span class='xb'>returnType</span>: <span class='xt'>GroupResult</span>.<span class='xk'>Type</span> = <span class='xv'>GroupResult</span>.<span class='xk'>self</span>, <span class='xi'></span><span class='xv'>body</span>: (<span class='xk'>inout</span> <span class='xt'>DiscardingTaskGroup</span>) <span class='xk'>async</span> -&gt; <span class='xt'>GroupResult</span><wbr>) <span class='xk'>async</span> -&gt; <span class='xt'>GroupResult</span></code></pre><p>Starts a new scope that can contain a dynamic number of child tasks.</p></a><a href='/docs/swift/_concurrency/discardingtaskgroup.addtask(operation:)'><pre><code><span class='xk'>mutating</span> <span class='xk'>func</span> <span class='xv'>addTask</span>(<span class='xi'></span><span class='xv'>operation</span>: <span class='xa'>@escaping</span> () <span class='xk'>async</span> -&gt; <span class='xt'>Void</span><wbr>)</code></pre></a><a href='/docs/swift-log/logging/logger.info(_:metadata:file:function:line:)'><pre><code><span class='xk'>func</span> <span class='xv'>info</span>(<span class='xi'></span>_ <span class='xb'>message</span>: <span class='xa'>@autoclosure</span> () -&gt; <span class='xt'>Logger</span>.<span class='xt'>Message</span>, <span class='xi'></span><span class='xv'>metadata</span>: <span class='xa'>@autoclosure</span> () -&gt; <span class='xt'>Logger</span>.<span class='xt'>Metadata</span>? = <span class='xk'>nil</span>, <span class='xi'></span><span class='xv'>file</span>: <span class='xt'>String</span> = #<span class='xv'>fileID</span>, <span class='xi'></span><span class='xv'>function</span>: <span class='xt'>String</span> = #<span class='xv'>function</span>, <span class='xi'></span><span class='xv'>line</span>: <span class='xt'>UInt</span> = #<span class='xv'>line</span><wbr>)</code></pre><p>Log a message passing with the <code>info</code> log level.</p></a><a href='/docs/swift-log/logging/logger/message.init(stringliteral:)'><pre><code><span class='xk'>init</span>(<span class='xi'></span><span class='xv'>stringLiteral</span> <span class='xb'>value</span>: <span class='xt'>String</span><wbr>)</code></pre></a><a href='/docs/swift-log/logging/logger/metadatavalue.string(_:)'><pre><code><span class='xk'>case</span> <span class='xv'>string</span>(<span class='xt'>String</span>)</code></pre><p>A metadata value which is a <code>String</code>.</p></a><a href='/docs/swift-log/logging/logger.debug(_:metadata:file:function:line:)'><pre><code><span class='xk'>func</span> <span class='xv'>debug</span>(<span class='xi'></span>_ <span class='xb'>message</span>: <span class='xa'>@autoclosure</span> () -&gt; <span class='xt'>Logger</span>.<span class='xt'>Message</span>, <span class='xi'></span><span class='xv'>metadata</span>: <span class='xa'>@autoclosure</span> () -&gt; <span class='xt'>Logger</span>.<span class='xt'>Metadata</span>? = <span class='xk'>nil</span>, <span class='xi'></span><span class='xv'>file</span>: <span class='xt'>String</span> = #<span class='xv'>fileID</span>, <span class='xi'></span><span class='xv'>function</span>: <span class='xt'>String</span> = #<span class='xv'>function</span>, <span class='xi'></span><span class='xv'>line</span>: <span class='xt'>UInt</span> = #<span class='xv'>line</span><wbr>)</code></pre><p>Log a message passing with the <code>debug</code> log level.</p></a><a href='/docs/swift-async-algorithms/asyncalgorithms/asyncchannel.finish'><pre><code><span class='xk'>func</span> <span class='xv'>finish</span>(<wbr>)</code></pre><p>Immediately resumes all the suspended operations. All subsequent calls to <code>next(_:)</code> will resume immediately.</p></a><a href='/docs/swift/_concurrency/discardingtaskgroup.cancelall'><pre><code><span class='xk'>func</span> <span class='xv'>cancelAll</span>(<wbr>)</code></pre><p>Cancel all of the remaining tasks in the group.</p></a><a href='/docs/swift/_concurrency/asyncstream/continuation.finish'><pre><code><span class='xk'>func</span> <span class='xv'>finish</span>(<wbr>)</code></pre><p>Resume the task awaiting the next iteration point by having it return nil, which signifies the end of the iteration.</p></a></div>