<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="canonical" href="https://swiftonserver.com/using-swiftnio-channels/">
    <link rel="prev" href="https://swiftonserver.com/using-openapi-with-hummingbird/">
    <link rel="next" href="https://swiftonserver.com/using-swiftnio-fundamentals/">

    <title>Using SwiftNIO - Channels - Swift on server</title>
    <meta name="description" content="Create a TCP server using SwiftNIO and structured concurrency">

    <meta property="og:url" content="https://swiftonserver.com/using-swiftnio-channels/">
    <meta property="og:title" content="Using SwiftNIO - Channels - Swift on server">
    <meta property="og:description" content="Create a TCP server using SwiftNIO and structured concurrency">
    <meta property="og:image" content="/assets/using-swiftnio-channels/cover.jpg" />

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Using SwiftNIO - Channels - Swift on server">
    <meta name="twitter:description" content="Create a TCP server using SwiftNIO and structured concurrency">
    <meta name="twitter:image" content="/assets/using-swiftnio-channels/cover.jpg">

    <link rel="stylesheet" href="https://swiftonserver.com/css/modern-normalize.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/modern-base.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/variables.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/base.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/grid.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/navigation.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/footer.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/syntax.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/style.css">

    

    <link rel="shortcut icon" href="https://swiftonserver.com/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://swiftonserver.com/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="https://swiftonserver.com/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="https://swiftonserver.com/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://swiftonserver.com/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://swiftonserver.com/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://swiftonserver.com/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://swiftonserver.com/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://swiftonserver.com/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://swiftonserver.com/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://swiftonserver.com/images/icons/apple-touch-icon-180x180.png">

    <script type="text/javascript" src="https://swiftonserver.com//js/tooltips.js" async=""></script>

    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
        media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)">
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
        media="(prefers-color-scheme: dark)"
    >

    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
          const container = document.querySelector("div#ss\\:tooltips");
          if (container !== null) {
              container.querySelectorAll('pre code').forEach((el) => {
                  el.classList.add('nohighlight');
              });
          }
        });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
          document.querySelectorAll('section pre code:not(.language-swift').forEach((el) => {
              hljs.highlightElement(el);
          });
        });
    </script>


</head>

<body>
    <div id="site-container">

    <header id="navigation">
        <a href="/">
            <figure>
                <picture>
                    <source
                        srcset="https://swiftonserver.com/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        src="https://swiftonserver.com/images/logos/logo.png"
                        alt="Logo of Swift on server"
                        title="Swift on server"
                    >
                </picture>
            </figure>
        </a>
        <nav>
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/posts/page/1/">Posts</a>
                <a href="/tags/">Tags</a>
                <a href="/authors/">Authors</a>
                <a href="/newsletter/">Newsletter</a>
            </div>
        </nav>
    </header>

    <main id="page-container">
    
    <div class="article-with-toc">
        <div>
            <article class="post">
                <div class="meta">
                    <time datetime="2024/02/08">2024/02/08</time>
                     &middot; <span class="reading-time">11 min read</span>
                    
                </div>
                <section>
                
                <section class='introduction'><h1>SwiftNIO Channels</h1></section><section class='details literature'><p>SwiftNIO revolves around networking. In SwiftNIO, reads and writes happen using a <code><a href='https://swiftinit.org/docs/swift-nio/niocore/channel' target='_blank' rel='external'>Channel</a></code>.</p><p>In the previous tutorial, <a href='../using-swiftnio-fundamentals'>SwiftNIO Fundamentals</a>, you’ve learned the fundamentals of SwiftNIO. You’re now familiar with the concept of an <code><a href='https://swiftinit.org/docs/swift-nio/niocore/eventloop' target='_blank' rel='external'>EventLoop</a></code>.</p><p>In this tutorial, you’ll be building a TCP server that echoes back any data that it receives. This is a very common pattern in network applications, and is a great way to get started with SwiftNIO. You’ll learn what <strong>Channels</strong> and <strong>Channel Pipelines</strong> are, and how SwiftNIO uses them to represent network connections. You’ll also learn about <strong>Channel Handlers</strong> and applying this knowledge using structured concurrency.</p><p>In order to start with this tutorial, <a href='https://github.com/swift-on-server/using-swiftnio-channels-sample' target='_blank' rel='external'>Download the Samples</a>. If you’re stuck, you can keep at the Finished product within that repo as well.</p><p>The samples make use of VSCode DevContainers (<a href='../developing-with-swift-in-visual-studio-code'>Developing with Swift in Visual Studio Code</a>) to provide a consistent development environment. If you’re not using VSCode, you can also use the latest Xcode.</p><h2 id='Channels'><a href='#Channels'>Channels</a></h2><p>In the previous aricle, you learned the concepts of an <code><a href='https://swiftinit.org/docs/swift-nio/niocore/eventloop' target='_blank' rel='external'>EventLoop</a></code>, Network I/O and sockets. You now know that a socket is represented by a file descriptor, and that you can read and write data to it.</p><p>The Sockets covered in the previous article are represented as a “Channel” in SwiftNIO. However, a Channel can be anything that is capable of I/O operations. This includes TCP and UDP connections, but can also extend to things such as Unix Domain Sockets, Pipes and even Serial USB connections.</p><p>A Channel is a very important concept in NIO, and is used extensivley throughout any networking application.</p><h3 id='A%20Channel%E2%80%99s%20Anatomy'><a href='#A%20Channel%E2%80%99s%20Anatomy'>A Channel’s Anatomy</a></h3><p>Channel is fundamentally a protocol that any connection can conform to. The protocol defines a variety of properties and functions that are relevant to connections. For example, many connections have a <code>localAddress</code> and <code>remoteAddress</code> property. These properties are used to identify the local and remote peer of a connection. Because Channel does not exclusively represent network connections, these properties are optional.</p><p>Most importantly, a Channel has a <code><a href='https://swiftinit.org/docs/swift-nio/niocore/channelpipeline' target='_blank' rel='external'>ChannelPipeline</a></code>. The pipeline processes all data that is sent and received by the Channel. You can think of the pipeline as an array of <code><a href='https://swiftinit.org/docs/swift-nio/niocore/channelhandler' target='_blank' rel='external'>ChannelHandler</a></code>s. These handlers are called in order, and can modify the data that is sent and received by the Channel.</p><p>Each ChannelHandler is usually responsible for a specific task. For example, the <code>NIOSSLHandler</code> is responsible for encrypting and decrypting data using TLS. For HTTP/1, you have a specific handler that parses HTTP requests. And another handler that serializes HTTP responses.</p><h3 id='Pipelines'><a href='#Pipelines'>Pipelines</a></h3><p>A channel can receive data, such as when it’s received from the network or a USB device. When this happens, the data is passed to the <code><a href='https://swiftinit.org/docs/swift-nio/niocore/channelpipeline' target='_blank' rel='external'>ChannelPipeline</a></code> at the head. This calls the first <code><a href='https://swiftinit.org/docs/swift-nio/niocore/channelinboundhandler' target='_blank' rel='external'>ChannelInboundHandler</a></code> in the pipeline. The flow of data makes its way from front-to-back, ending at the tail, calling only InboundHandlers. Each of these handlers can ‘process’ the data, by transforming the information or even changing the type of data in the pipeline.</p><p>When a channel is asked to send data, the data also goes through the pipeline, but starts at the tail. This calls the last handler in the pipeline, and only calls <code><a href='https://swiftinit.org/docs/swift-nio/niocore/channeloutboundhandler' target='_blank' rel='external'>ChannelOutboundHandler</a></code>. Each of these handlers can also process the data, and can also change the type of data in the pipeline.</p><p>The type of data that a pipeline receives at the head when data is read, is specified by the Channel. This means that the first InboundHandler’s must accept the type of data that the <code><a href='https://swiftinit.org/docs/swift-nio/niocore/channel' target='_blank' rel='external'>Channel</a></code> emits when reading data off the network. Likewise, whatever the Pipeline ends up writing data to a <code><a href='https://swiftinit.org/docs/swift-nio/niocore/channel' target='_blank' rel='external'>Channel</a></code>, the type of data written must match what the <code><a href='https://swiftinit.org/docs/swift-nio/niocore/channel' target='_blank' rel='external'>Channel</a></code> can handle. Note that if these types don’t match, SwiftNIO will crash your application at <strong>runtime</strong>.</p><h3 id='Channel%20Handlers'><a href='#Channel%20Handlers'>Channel Handlers</a></h3><p>An InboundHandler specifies two associated types, the <code>InboundIn</code> and <code>InboundOut</code>. The <em>InboundIn</em> type is the input of the handler when reading data. For example, <code><a href='https://swiftinit.org/docs/swift-nio/niocore/bytebuffer' target='_blank' rel='external'>ByteBuffer</a></code> is used by NIO to represent binary data. The <em>InboundOut</em> specifies any output that this handler <em>outputs</em>. When parsing an HTTP Request using the built-in HTTP/1 parser, the handler accepts <code><a href='https://swiftinit.org/docs/swift-nio/niocore/bytebuffer' target='_blank' rel='external'>ByteBuffer</a></code> for input and produces an <code><a href='https://swiftinit.org/docs/swift-nio/niohttp1/httpserverrequestpart' target='_blank' rel='external'>HTTPServerRequestPart</a></code> when it parses a part of the HTTP request.</p><p>When the handler has processed the data, it can pass the transformed data on to the next handler in the pipeline. If a channel handler does not modify the output, it can simply pass on the data to the next handler. When the handler modifies data, this is done by calling <code>fireChannelRead</code> on the <code><a href='https://swiftinit.org/docs/swift-nio/niocore/channelhandlercontext' target='_blank' rel='external'>ChannelHandlerContext</a></code>. This context is provided during the <code>channelRead</code> function call where you receive inbound data.</p><p>The data you emit (InboundOut) must match the expected input type of the next handler in the pipeline. If the types don’t match, SwiftNIO will also crash your application at runtime. This is why it’s important to understand the types that each handler accepts and emits.</p><p>Using code such as <a href='https://github.com/orlandos-nl/omnibus' target='_blank' rel='external'>Omnibus</a>, you can create these pipeline in a type-checked way. This ensures that your pipeline is valid at compile-time, rather than runtime.</p><p>The OutboundHandler works in an identical way to the InboundHandler. The <code>OutboundIn</code> type is the type of data that the handler accepts, and the <code>OutboundOut</code> type is the type of data that the handler emits. Processing data instead happens in the <code>write</code> function, rather than the <code>channelRead</code> function.</p><h2 id='Creating%20a%20TCP%20Echo%20Server'><a href='#Creating%20a%20TCP%20Echo%20Server'>Creating a TCP Echo Server</a></h2><p>Now that you understand the basics of Channels and Pipelines, let’s apply our knowledge to create a TCP Echo Server. This server, built using structured concurrency, will accept TCP connections. When it receives a message, itll echo back any data that it receives.</p><h3 id='Creating%20a%20ServerBootstrap'><a href='#Creating%20a%20ServerBootstrap'>Creating a ServerBootstrap</a></h3><p>In order to create a TCP server, you’ll first need to create a <code><a href='https://swiftinit.org/docs/swift-nio/nioposix/serverbootstrap' target='_blank' rel='external'>ServerBootstrap</a></code>. This is a type that’s provided by SwiftNIO, and is used to create a server Channel that emits client channels.</p><p>ServerBootstrap requires an <code><a href='https://swiftinit.org/docs/swift-nio/niocore/eventloopgroup' target='_blank' rel='external'>EventLoopGroup</a></code> to run on. This is a group of EventLoops that the server will use to run on. Each client will be handled by a single specific <code><a href='https://swiftinit.org/docs/swift-nio/niocore/eventloop' target='_blank' rel='external'>EventLoop</a></code>, that is randomly assigned. This helps your server scale to many threads (and cores) without having to worry about thread-safety.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xc'>// 1.</span><span class='newline'>
</span><span class='xk'>let</span> <span class='xv'>server</span> = <span class='xk'>try</span> <span class='xk'>await</span> <a class='xt' href='https://swiftinit.org/docs/swift-nio/nioposix/serverbootstrap' target='_blank' rel='external'>ServerBootstrap</a>(<span class='xv'>group</span>: <a class='xt' href='https://swiftinit.org/docs/swift-nio/niocore/niosingletons' target='_blank' rel='external'>NIOSingletons</a>.<a class='xv' href='https://swiftinit.org/docs/swift-nio/niocore/niosingletons.posixeventloopgroup' target='_blank' rel='external'>posixEventLoopGroup</a>)<span class='newline'>
</span>    .<a class='xv' href='https://swiftinit.org/docs/swift-nio/nioposix/serverbootstrap.bind(host:port:serverbackpressurestrategy:childchannelinitializer:)' target='_blank' rel='external'>bind</a>(  <span class='xc'>// 2.</span><span class='newline'>
</span>        <span class='xv'>host</span>: <span class='xs'>"0.0.0.0"</span>,  <span class='xc'>// 3.</span><span class='newline'>
</span>        <span class='xv'>port</span>: <span class='xn'>2048</span>  <span class='xc'>// 4.</span><span class='newline'>
</span>    ) { <span class='xv'>channel</span> <span class='xk'>in</span><span class='newline'>
</span>        <span class='xc'>// 5.</span><span class='newline'>
</span>        <span class='xv'>channel</span>.<a class='xv' href='https://swiftinit.org/docs/swift-nio/niocore/channeloutboundinvoker.eventloop' target='_blank' rel='external'>eventLoop</a>.<a class='xv' href='https://swiftinit.org/docs/swift-nio/niocore/eventloop.makecompletedfuture(withresultof:)' target='_blank' rel='external'>makeCompletedFuture</a> {<span class='newline'>
</span>            <span class='xc'>// Add any handlers for parsing or serializing messages here</span><span class='newline'>
</span>            <span class='xc'>// We don't need any for this echo example</span><span class='newline'>

</span>            <span class='xc'>// 6.</span><span class='newline'>
</span>            <span class='xk'>return</span> <span class='xk'>try</span> <a class='xt' href='https://swiftinit.org/docs/swift-nio/niocore/nioasyncchannel' target='_blank' rel='external'>NIOAsyncChannel</a>(<span class='newline'>
</span>                <span class='xv'>wrappingChannelSynchronously</span>: <span class='xv'>channel</span>,<span class='newline'>
</span>                <span class='xv'>configuration</span>: <a class='xt' href='https://swiftinit.org/docs/swift-nio/niocore/nioasyncchannel' target='_blank' rel='external'>NIOAsyncChannel</a>.<a class='xt' href='https://swiftinit.org/docs/swift-nio/niocore/nioasyncchannel/configuration' target='_blank' rel='external'>Configuration</a>(<span class='newline'>
</span>                    <span class='xv'>inboundType</span>: <a class='xt' href='https://swiftinit.org/docs/swift-nio/niocore/bytebuffer' target='_blank' rel='external'>ByteBuffer</a>.<span class='xk'>self</span>,  <span class='xc'>// We'll read the raw bytes from the socket</span><span class='newline'>
</span>                    <span class='xv'>outboundType</span>: <a class='xt' href='https://swiftinit.org/docs/swift-nio/niocore/bytebuffer' target='_blank' rel='external'>ByteBuffer</a>.<span class='xk'>self</span>  <span class='xc'>// We'll also write raw bytes to the socket</span><span class='newline'>
</span>                )<span class='newline'>
</span>            )<span class='newline'>
</span>        }<span class='newline'>
</span>    }</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/using-swiftnio-channels.swift#L4' target='_blank' class='source github'><span class='file'>using-swiftnio-channels.swift</span>:<span class='line'>4</span></a><p>The above code can create a TCP server, without any logic to accept or communicate with clients. Let’s go over the code step-by-step:</p><ol><li><p>Create a bootstrap using a global <code><a href='https://swiftinit.org/docs/swift-nio/niocore/eventloopgroup' target='_blank' rel='external'>EventLoopGroup</a></code>. This is a recommended default EventLoopGoup.</p></li><li><p>Bind the socket to a specific host and port. This will start listening for incoming connections.</p></li><li><p>The host speciifes the IP address that the server will listen on. <code>0.0.0.0</code> is a special IP address that means “all IP addresses”, allowing connections from all network interfaces.</p></li><li><p>Set the port that the server will listen on. This port is what clients will connect to.</p></li><li><p>This closure is called for every client that connects to the server. This allows us to set up the pipeline for each client. In this case we don’t need any configuration. Note that this is one of the few remaining APIs where you can’t use <code>async</code>/<code>await</code>.</p></li><li><p>Wrap the <code><a href='https://swiftinit.org/docs/swift-nio/niocore/channel' target='_blank' rel='external'>Channel</a></code> in an <code><a href='https://swiftinit.org/docs/swift-nio/niocore/nioasyncchannel' target='_blank' rel='external'>NIOAsyncChannel</a></code>. This is a type that’s provided by SwiftNIO, and allows interating with Channels in a way that fully embraces structured concurrency.</p></li></ol><h3 id='Accepting%20Clients'><a href='#Accepting%20Clients'>Accepting Clients</a></h3><p>With this newly created server, this code can start accepting clients. Let’s implement that:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xc'>// 1.</span><span class='newline'>
</span><span class='xk'>try</span> <span class='xk'>await</span> <a class='xv' href='https://swiftinit.org/docs/swift/_concurrency.withthrowingdiscardingtaskgroup(returning:body:)' target='_blank' rel='external'>withThrowingDiscardingTaskGroup</a> { <span class='xv'>group</span> <span class='xk'>in</span><span class='newline'>
</span>    <span class='xc'>// 2.</span><span class='newline'>
</span>    <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>server</span>.<a class='xv' href='https://swiftinit.org/docs/swift-nio/niocore/nioasyncchannel.executethenclose(_:)?hash=63NMU' target='_blank' rel='external'>executeThenClose</a> { <span class='xv'>clients</span> <span class='xk'>in</span><span class='newline'>
</span>        <span class='xc'>// 3.</span><span class='newline'>
</span>        <span class='xk'>for</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>client</span> <span class='xk'>in</span> <span class='xv'>clients</span> {<span class='newline'>
</span>            <span class='xc'>// 4.</span><span class='newline'>
</span>            <span class='xv'>group</span>.<a class='xv' href='https://swiftinit.org/docs/swift/_concurrency/throwingdiscardingtaskgroup.addtask(priority:operation:)' target='_blank' rel='external'>addTask</a> {<span class='newline'>
</span>                <span class='xc'>// 5.</span><span class='newline'>
</span>                <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>handleClient</span>(<span class='xv'>client</span>)<span class='newline'>
</span>            }<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/using-swiftnio-channels.swift#L30' target='_blank' class='source github'><span class='file'>using-swiftnio-channels.swift</span>:<span class='line'>30</span></a><p>This code is an implementation of the server bootstrap that was created in the previous snippet. Let’s go over the code step-by-step:</p><ol><li><p>Create a task group to manage the lifetime of our server</p></li><li><p>By calling <code><a href='https://swiftinit.org/docs/swift-nio/niocore/nioasyncchannel.executethenclose(_:)?hash=2G196' target='_blank' rel='external'>executeThenClose(_:)</a></code>, receive a sequence of incoming clients. Once this sequence ends, the end of the function is reached and the server is closed.</p></li><li><p>A for-loop is used to iterate over each new client, allowing us to handle their traffic.</p></li><li><p>By adding a task to the task group, this Swift code can handle many clients in parallel</p></li><li><p>Call <code>handleClient</code> to handle the client. This will be a separate function that will be implemented in a moment.</p></li></ol><h3 id='Handling%20a%20Client'><a href='#Handling%20a%20Client'>Handling a Client</a></h3><p>The server is not able to accept client, but can not yet communicate with them. Let’s implement that:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>func</span> <span class='xv'>handleClient</span>(_ <span class='xv'>client</span>: <a class='xt' href='https://swiftinit.org/docs/swift-nio/niocore/nioasyncchannel' target='_blank' rel='external'>NIOAsyncChannel</a>&lt;<a class='xt' href='https://swiftinit.org/docs/swift-nio/niocore/bytebuffer' target='_blank' rel='external'>ByteBuffer</a>, <a class='xt' href='https://swiftinit.org/docs/swift-nio/niocore/bytebuffer' target='_blank' rel='external'>ByteBuffer</a>&gt;)<span class='newline'>
</span>    <span class='xk'>async</span> <span class='xk'>throws</span><span class='newline'>
</span>{<span class='newline'>
</span>    <span class='xc'>// 1.</span><span class='newline'>
</span>    <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>client</span>.<a class='xv' href='https://swiftinit.org/docs/swift-nio/niocore/nioasyncchannel.executethenclose(_:)?hash=2G196' target='_blank' rel='external'>executeThenClose</a> { <span class='xv'>inboundMessages</span>, <span class='xv'>outbound</span> <span class='xk'>in</span><span class='newline'>
</span>        <span class='xc'>// 2.</span><span class='newline'>
</span>        <span class='xk'>for</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>inboundMessage</span> <span class='xk'>in</span> <span class='xv'>inboundMessages</span> {<span class='newline'>
</span>            <span class='xc'>// 3.</span><span class='newline'>
</span>            <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>outbound</span>.<a class='xv' href='https://swiftinit.org/docs/swift-nio/niocore/nioasyncchanneloutboundwriter.write(_:)' target='_blank' rel='external'>write</a>(<span class='xv'>inboundMessage</span>)<span class='newline'>

</span>            <span class='xc'>// MARK: A</span><span class='newline'>
</span>            <span class='xk'>return</span><span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/using-swiftnio-channels.swift#L47' target='_blank' class='source github'><span class='file'>using-swiftnio-channels.swift</span>:<span class='line'>47</span></a><p>This code receives messages from a client, and echoes it back. It’s functional, efficient and easy to understand. Let’s go over the code step-by-step:</p><ol><li><p>Call <code><a href='https://swiftinit.org/docs/swift-nio/niocore/nioasyncchannel.executethenclose(_:)?hash=2G196' target='_blank' rel='external'>executeThenClose(_:)</a></code> on the client. This allows us to receive a sequence of inbound messages, and a handle to write messages back.</p></li><li><p>Iterate over each inbound message, using a for-loop.</p></li><li><p>Write the inbound message back to the client.</p></li></ol><p>When the client closes the connection, the sequence of inbound messages will end. This causes the <code><a href='https://swiftinit.org/docs/swift-nio/niocore/nioasyncchannel.executethenclose(_:)?hash=2G196' target='_blank' rel='external'>executeThenClose(_:)</a></code> function will return, and the client will be cleaned up.</p><p>You can try connecting yourself by running the following in your terminal. If a connection is successful, you’ll get prompt where you can type a message. When you press enter, the message will be echoed back to you.</p><pre class='snippet'><code class='language-bash'><span class='newline'></span>nc localhost 2048</code></pre><p>If you want, close the connection from our side as well. I’ve placed a marker where you can close the connection from our side. Because <code><a href='https://swiftinit.org/docs/swift-nio/niocore/nioasyncchannel.executethenclose(_:)?hash=2G196' target='_blank' rel='external'>executeThenClose(_:)</a></code> will close the connection when the function ends, simply place a <code>return</code> statement here.</p><h2 id='Conclusion'><a href='#Conclusion'>Conclusion</a></h2><p>In this tutorial, you’ve learned the concept of Channels and Pipelines. You’ve also created a simple TCP server using SwiftNIO. All with structured concurrency!</p><p>In the next tutorial, (<a href='../building-swiftnio-clients'>Building a SwiftNIO HTTP client</a>, we’ll cover how to suppport a protocol (HTTP/1) by using Channel Handlers, by building an HTTP client.</p></section><div style='display: none;' id='ss:tooltips'><a href='/docs/swift-nio/niocore/channel'><pre><code><span class='xk'>protocol</span> <span class='xv'>Channel</span> : <span class='xt'>AnyObject</span>, <span class='xt'>ChannelOutboundInvoker</span>, <span class='xt'>_NIOPreconcurrencySendable</span></code></pre><p>A <code>Channel</code> is easiest thought of as a network socket. But it can be anything that is capable of I/O operations such as read, write, connect, and bind.</p></a><a href='/hist/swift-on-server.articles:main/articles/using-swiftnio-fundamentals'><p>SwiftNIO is a brilliant framework that’s developed and maintained by Apple. It’s used for network application development, usually but not exclusively by libraries.</p></a><a href='/docs/swift-nio/niocore/eventloop'><pre><code><span class='xk'>protocol</span> <span class='xv'>EventLoop</span> : <span class='xt'>EventLoopGroup</span></code></pre><p>An EventLoop processes IO / tasks in an endless loop for <code>Channel</code>s until it’s closed.</p></a><a href='/hist/swift-on-server.articles:main/articles/developing-with-swift-in-visual-studio-code'><p>Swift is a great language for developing applications for Apple platforms, and is easily set up using Xcode. However, Xcode is only available for macOS, and does not support a wide variety of extensions.</p></a><a href='/docs/swift-nio/niocore/channelpipeline'><pre><code><span class='xk'>final</span> <span class='xk'>class</span> <span class='xv'>ChannelPipeline</span></code></pre><p>A list of <code>ChannelHandler</code>s that handle or intercept inbound events and outbound operations of a <code>Channel</code>. <code>ChannelPipeline</code> implements an advanced form of the Intercepting Filter pattern to give a user full control over how an event is handled and how the <code>ChannelHandler</code>s in a pipeline interact with each other.</p></a><a href='/docs/swift-nio/niocore/channelhandler'><pre><code><span class='xk'>protocol</span> <span class='xv'>ChannelHandler</span> : <span class='xt'>AnyObject</span></code></pre><p>Base protocol for handlers that handle I/O events or intercept an I/O operation.</p></a><a href='/docs/swift-nio/niocore/channelinboundhandler'><pre><code><span class='xk'>protocol</span> <span class='xv'>ChannelInboundHandler</span> : <span class='xt'>_ChannelInboundHandler</span>, <span class='xt'>_EmittingChannelHandler</span></code></pre><p><code>ChannelHandler</code> which handles inbound I/O events for a <code>Channel</code>.</p></a><a href='/docs/swift-nio/niocore/channeloutboundhandler'><pre><code><span class='xk'>protocol</span> <span class='xv'>ChannelOutboundHandler</span> : <span class='xt'>_ChannelOutboundHandler</span>, <span class='xt'>_EmittingChannelHandler</span></code></pre><p><code>ChannelHandler</code> which handles outbound I/O events or intercept an outbound I/O operation for a <code>Channel</code>.</p></a><a href='/docs/swift-nio/niocore/bytebuffer'><pre><code><span class='xk'>struct</span> <span class='xv'>ByteBuffer</span></code></pre><p><code>ByteBuffer</code> stores contiguously allocated raw bytes. It is a random and sequential accessible sequence of zero or more bytes (octets).</p></a><a href='/docs/swift-nio/niohttp1/httpserverrequestpart'><pre><code><span class='xk'>typealias</span> <span class='xv'>HTTPServerRequestPart</span> = <span class='xt'>HTTPPart</span>&lt;<span class='xt'>HTTPRequestHead</span>, <span class='xt'>ByteBuffer</span>&gt;</code></pre><p>The components of a HTTP request from the view of a HTTP server.</p></a><a href='/docs/swift-nio/niocore/channelhandlercontext'><pre><code><span class='xk'>final</span> <span class='xk'>class</span> <span class='xv'>ChannelHandlerContext</span></code></pre><p>Every <code>ChannelHandler</code> has – when added to a <code>ChannelPipeline</code> – a corresponding <code>ChannelHandlerContext</code> which is the way <code>ChannelHandler</code>s can interact with other <code>ChannelHandler</code>s in the pipeline.</p></a><a href='/docs/swift-nio/nioposix/serverbootstrap'><pre><code><span class='xk'>final</span> <span class='xk'>class</span> <span class='xv'>ServerBootstrap</span></code></pre><p>A <code>ServerBootstrap</code> is an easy way to bootstrap a <code>ServerSocketChannel</code> when creating network servers.</p></a><a href='/docs/swift-nio/niocore/eventloopgroup'><pre><code><span class='xk'>protocol</span> <span class='xv'>EventLoopGroup</span> : <span class='xt'>AnyObject</span>, <span class='xt'>_NIOPreconcurrencySendable</span></code></pre><p>Provides an endless stream of <code>EventLoop</code>s to use.</p></a><a href='/docs/swift-nio/niocore/niosingletons'><pre><code><span class='xk'>enum</span> <span class='xv'>NIOSingletons</span></code></pre><p>SwiftNIO provided singleton resources for programs &amp; libraries that don’t need full control over all operating system resources. This type holds sizing (how many loops/threads) suggestions.</p></a><a href='/docs/swift-nio/niocore/niosingletons.posixeventloopgroup'><pre><code><span class='xk'>static</span> <span class='xk'>var</span> <span class='xv'>posixEventLoopGroup</span>: <span class='xt'>MultiThreadedEventLoopGroup</span> { <span class='xk'>get</span> }</code></pre><p>A globally shared, lazily initialized <code>MultiThreadedEventLoopGroup</code>  that uses <code>epoll</code>/<code>kqueue</code> as the selector mechanism.</p></a><a href='/docs/swift-nio/nioposix/serverbootstrap.bind(host:port:serverbackpressurestrategy:childchannelinitializer:)'><pre><code><span class='xk'>func</span> <span class='xv'>bind</span>&lt;<span class='xu'>Output</span>&gt;(<span class='xi'></span><span class='xv'>host</span>: <span class='xt'>String</span>, <span class='xi'></span><span class='xv'>port</span>: <span class='xt'>Int</span>, <span class='xi'></span><span class='xv'>serverBackPressureStrategy</span>: <span class='xt'>NIOAsyncSequenceProducerBackPressureStrategies</span>.<span class='xt'>HighLowWatermark</span>? = <span class='xk'>nil</span>, <span class='xi'></span><span class='xv'>childChannelInitializer</span>: <span class='xa'>@escaping</span> (<span class='xk'>any</span> <span class='xt'>Channel</span>) -&gt; <span class='xt'>EventLoopFuture</span>&lt;<span class='xt'>Output</span>&gt;<wbr>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>NIOAsyncChannel</span>&lt;<span class='xt'>Output</span>, <span class='xt'>Never</span>&gt; <span class='xk'>where</span> <span class='xt'>Output</span> : <span class='xt'>Sendable</span></code></pre><p>Bind the <code>ServerSocketChannel</code> to the <code>host</code> and <code>port</code> parameters.</p></a><a href='/docs/swift-nio/niocore/channeloutboundinvoker.eventloop'><pre><code><span class='xk'>var</span> <span class='xv'>eventLoop</span>: <span class='xk'>any</span> <span class='xt'>EventLoop</span> { <span class='xk'>get</span> }</code></pre><p>The <code>EventLoop</code> which is used by this <code>ChannelOutboundInvoker</code> for execution.</p></a><a href='/docs/swift-nio/niocore/eventloop.makecompletedfuture(withresultof:)'><pre><code><span class='xk'>func</span> <span class='xv'>makeCompletedFuture</span>&lt;<span class='xu'>Success</span>&gt;(<span class='xi'></span><span class='xv'>withResultOf</span> <span class='xb'>body</span>: () <span class='xk'>throws</span> -&gt; <span class='xt'>Success</span><wbr>) -&gt; <span class='xt'>EventLoopFuture</span>&lt;<span class='xt'>Success</span>&gt;</code></pre><p>Creates and returns a new <code>EventLoopFuture</code> that is marked as succeeded or failed with the value returned by <code>body</code>.</p></a><a href='/docs/swift-nio/niocore/nioasyncchannel'><pre><code><span class='xk'>struct</span> <span class='xv'>NIOAsyncChannel</span>&lt;<span class='xu'>Inbound</span>, <span class='xu'>Outbound</span>&gt; <span class='xk'>where</span> <span class='xt'>Inbound</span> : <span class='xt'>Sendable</span>, <span class='xt'>Outbound</span> : <span class='xt'>Sendable</span></code></pre><p>Wraps a NIO <code>Channel</code> object into a form suitable for use in Swift Concurrency.</p></a><a href='/docs/swift-nio/niocore/nioasyncchannel/configuration'><pre><code><span class='xk'>struct</span> <span class='xv'>Configuration</span></code></pre></a><a href='/docs/swift/_concurrency.withthrowingdiscardingtaskgroup(returning:body:)'><pre><code><span class='xk'>func</span> <span class='xv'>withThrowingDiscardingTaskGroup</span>&lt;<span class='xu'>GroupResult</span>&gt;(<span class='xi'></span><span class='xv'>returning</span> <span class='xb'>returnType</span>: <span class='xt'>GroupResult</span>.<span class='xk'>Type</span> = <span class='xv'>GroupResult</span>.<span class='xk'>self</span>, <span class='xi'></span><span class='xv'>body</span>: (<span class='xk'>inout</span> <span class='xt'>ThrowingDiscardingTaskGroup</span>&lt;<span class='xk'>any</span> <span class='xt'>Error</span>&gt;) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>GroupResult</span><wbr>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>GroupResult</span></code></pre><p>Starts a new scope that can contain a dynamic number of child tasks.</p></a><a href='/docs/swift-nio/niocore/nioasyncchannel.executethenclose(_:)?hash=63NMU'><pre><code><span class='xk'>func</span> <span class='xv'>executeThenClose</span>&lt;<span class='xu'>Result</span>&gt;(<span class='xi'></span>_ <span class='xb'>body</span>: (<span class='xt'>NIOAsyncChannelInboundStream</span>&lt;<span class='xt'>Inbound</span>&gt;) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>Result</span><wbr>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>Result</span> <span class='xk'>where</span> <span class='xt'>Outbound</span> <span class='xo'>==</span> <span class='xt'>Never</span></code></pre><p>Provides scoped access to the inbound side of the underlying <code>Channel</code>.</p></a><a href='/docs/swift/_concurrency/throwingdiscardingtaskgroup.addtask(priority:operation:)'><pre><code><span class='xk'>mutating</span> <span class='xk'>func</span> <span class='xv'>addTask</span>(<span class='xi'></span><span class='xv'>priority</span>: <span class='xt'>TaskPriority</span>? = <span class='xk'>nil</span>, <span class='xi'></span><span class='xv'>operation</span>: <span class='xa'>@escaping</span> () <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>Void</span><wbr>)</code></pre></a><a href='/docs/swift-nio/niocore/nioasyncchannel.executethenclose(_:)?hash=2G196'><pre><code><span class='xk'>func</span> <span class='xv'>executeThenClose</span>&lt;<span class='xu'>Result</span>&gt;(<span class='xi'></span>_ <span class='xb'>body</span>: (<span class='xt'>NIOAsyncChannelInboundStream</span>&lt;<span class='xt'>Inbound</span>&gt;, <span class='xt'>NIOAsyncChannelOutboundWriter</span>&lt;<span class='xt'>Outbound</span>&gt;) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>Result</span><wbr>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>Result</span></code></pre><p>Provides scoped access to the inbound and outbound side of the underlying <code>Channel</code>.</p></a><a href='/docs/swift-nio/niocore/nioasyncchanneloutboundwriter.write(_:)'><pre><code><span class='xk'>func</span> <span class='xv'>write</span>(<span class='xi'></span>_ <span class='xb'>data</span>: <span class='xt'>OutboundOut</span><wbr>) <span class='xk'>async</span> <span class='xk'>throws</span></code></pre><p>Send a write into the <code>ChannelPipeline</code> and flush it right away.</p></a><a href='/hist/swift-on-server.articles:main/articles/building-swiftnio-clients'><p>HTTP clients are a common first networking application to build. HTTP is a well known and simple to understand protocol, making it an excellent start.</p></a></div>
                    
                </section>
    
                <footer>
                    <br>
                    <time datetime=""></time>
    
                    
                    <div class="author-list">
                        <a href="https://swiftonserver.com/authors/joannis-orlandos/">
                        <img class="small rounded" src="/assets/authors/joannis-orlandos/joannis-orlandos.jpeg" alt="Joannis Orlandos">
                        <span class="name">Joannis Orlandos</span>
                        </a>
                    </div>
                    <div class="tag-list">
                        <a href="https://swiftonserver.com/tags/networking/"><small>Networking</small></a><small>, </small>
                    <a href="https://swiftonserver.com/tags/server/"><small>Server</small></a><small>, </small>
                    <a href="https://swiftonserver.com/tags/swiftnio/"><small>SwiftNIO</small></a>
                    </div>
                </footer>
                            
                <section class="group">
                    <h4>Related posts</h4>                
                    <div class="grid grid-221">
                        <div class="card">
                            
                            
                            <div class="author-list">
                            </div>
                            <div class="meta">
                                <time datetime="2024/06/27">2024/06/27</time>
                                
                            </div>
                            
                            <h2 class="title"><a href="https://swiftonserver.com/websockets-tutorial-using-swift-and-hummingbird/" target="">WebSocket tutorial using Swift and Hummingbird</a></h2>
                            <p>In this article, you will learn about WebSockets and how to use them with the Hummingbird framework in a straightforward, easy-to-follow manner.</p>
                        
                            <div class="tag-list">
                            </div>
                        </div>
                    <div class="card">
                            
                            
                            <div class="author-list">
                            </div>
                            <div class="meta">
                                <time datetime="2024/04/03">2024/04/03</time>
                                
                            </div>
                            
                            <h2 class="title"><a href="https://swiftonserver.com/async-http-client-by-example/" target="">AsyncHTTPClient by example</a></h2>
                            <p>This article offers practical examples to introduce the Swift AsyncHTTPClient library.</p>
                        
                            <div class="tag-list">
                            </div>
                        </div>
                    <div class="card">
                            
                            
                            <div class="author-list">
                            </div>
                            <div class="meta">
                                <time datetime="2024/03/05">2024/03/05</time>
                                
                            </div>
                            
                            <h2 class="title"><a href="https://swiftonserver.com/using-openapi-with-hummingbird/" target="">Using OpenAPI Generator with Hummingbird</a></h2>
                            <p>Learn how to use OpenAPI Generator to create Swift APIs with Hummingbird.</p>
                        
                            <div class="tag-list">
                            </div>
                        </div>
                    <div class="card">
                            
                            
                            <div class="author-list">
                            </div>
                            <div class="meta">
                                <time datetime="2024/02/27">2024/02/27</time>
                                
                            </div>
                            
                            <h2 class="title"><a href="https://swiftonserver.com/whats-new-in-hummingbird-2/" target="">What&#39;s new in Hummingbird 2?</a></h2>
                            <p>Discover Hummingbird 2: a Swift-based HTTP server framework, with modern concurrency and customizable request contexts.</p>
                        
                            <div class="tag-list">
                            </div>
                        </div>
                    <div class="card">
                            
                            
                            <div class="author-list">
                            </div>
                            <div class="meta">
                                <time datetime="2024/02/20">2024/02/20</time>
                                
                            </div>
                            
                            <h2 class="title"><a href="https://swiftonserver.com/building-swiftnio-clients/" target="">Building an HTTP client using SwiftNIO</a></h2>
                            <p>Learn how to build a simple HTTP client using SwiftNIO and structured concurrency.</p>
                        
                            <div class="tag-list">
                            </div>
                        </div>
                    <div class="card">
                            
                            
                            <div class="author-list">
                            </div>
                            <div class="meta">
                                <time datetime="2024/01/30">2024/01/30</time>
                                
                            </div>
                            
                            <h2 class="title"><a href="https://swiftonserver.com/using-swiftnio-fundamentals/" target="">Using SwiftNIO - Fundamentals</a></h2>
                            <p>Learn the fundamental concepts of SwiftNIO, such as EventLoops and nonblocking I/O</p>
                        
                            <div class="tag-list">
                            </div>
                        </div>
                    </div>
                </section>
    
            </article>
        </div>
        
        <div>
            <div class="support">
                <a href="https://www.serversideswift.info/" target="_blank">
                    <img src="https://swiftonserver.com//images/logos/serversideswift.png" alt="Server-Side Swift Conference logo">
                </a>
                <h4>
                    <a href="https://www.serversideswift.info/" target="_blank">ServerSide.swift</a>
                </h4>
                <p>26th-27th September 2024. London, UK</p>
                <p>Discount code: <strong><a href="https://ti.to/serverside-swift/2024/discount/SWIFTONSERVER" target="_blank">SWIFTONSERVER</a></strong></p>
                <a class="cta" href="https://www.serversideswift.info/tickets/" target="_blank">Buy a ticket</a>
            </div>
            
            <aside id="toc">
                <h4>On this page</h4>
                <ul>
                    <li class="first-level">
                        <a href="#Channels">Channels</a>
                        <ul>
                            <li><a href="#A%20Channel%E2%80%99s%20Anatomy">A Channel’s Anatomy</a></li>
                <li><a href="#Pipelines">Pipelines</a></li>
                <li><a href="#Channel%20Handlers">Channel Handlers</a></li>
                        </ul>
                    </li>
        <li class="first-level">
                        <a href="#Creating%20a%20TCP%20Echo%20Server">Creating a TCP Echo Server</a>
                        <ul>
                            <li><a href="#Creating%20a%20ServerBootstrap">Creating a ServerBootstrap</a></li>
                <li><a href="#Accepting%20Clients">Accepting Clients</a></li>
                <li><a href="#Handling%20a%20Client">Handling a Client</a></li>
                        </ul>
                    </li>
        <li class="first-level">
                        <a href="#Conclusion">Conclusion</a>
                        <ul>
                        </ul>
                    </li>
                </ul>
            </aside>
    
        </div>
    </div>
    
    </main>

    <footer id="site-footer">
        <div class="grid grid-421">
    
            <figure>
                <picture>
                    <source
                        srcset="https://swiftonserver.com/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="https://swiftonserver.com/images/logos/logo.png"
                        alt="Logo of Swift on server"
                        title="Swift on server"
                    >
                </picture>
            </figure>
            
            <div>
                <span style="display: block; height: 32px;">&nbsp;</span>
                <h4>Swift on server</h4>
                <p><small><a href="https://swiftonserver.com/" target="_blank">swiftonserver.com</a></small></p>
                <ul>
                    <li><a href="https://github.com/swift-on-server/" target="_blank">GitHub</a></li>
                    <li><a href="https://mastodon.social/@swiftonserver/" target="_blank">Mastodon</a></li>
                    <li><a href="https://swiftonserver.com/rss.xml" target="_blank">RSS</a></li>
                    <li><a href="https://swiftonserver.com/sitemap.xml" target="_blank">Sitemap</a></li>
                </ul>
            </div>
            
            <div>
                <a href="https://swiftonserver.com/authors/joannis-orlandos/">
                <img class="small rounded" src="https://swiftonserver.com/assets/authors/joannis-orlandos/joannis-orlandos.jpeg" alt="Joannis Orlandos">
                </a>
                <h4><a href="https://swiftonserver.com/authors/joannis-orlandos/">Joannis Orlandos</a></h4>
                <p><small><a href="https://unbeatable.software/" target="_blank">Unbeatable Software B.V.</a></small></p>
                <ul>
                    <li><a href="mailto:hello@unbeatable.software" target="_blank">Email</a></li>
                    <li><a href="https://github.com/Joannis" target="_blank">GitHub</a></li>
                    <li><a href="https://x.com/JoannisOrlandos" target="_blank">X (Twitter)</a></li>
                    <li><a href="https://mastodon.social/@joannis@fosstodon.org" target="_blank">Mastodon</a></li>
                </ul>
            </div>
            
            <div>
                <a href="https://swiftonserver.com/authors/tibor-bodecs/">
                <img class="small rounded" src="https://swiftonserver.com/assets/authors/tibor-bodecs/tibor-bodecs.jpeg" alt="Tibor Bödecs">
                </a>
                <h4><a href="https://swiftonserver.com/authors/tibor-bodecs/">Tibor Bödecs</a></h4>
                <p><small><a href="https://binarybirds.com/" target="_blank">Binary Birds Kft.</a></small></p>
                <ul>
                    <li><a href="mailto:mail.tib@gmail.com" target="_blank">Email</a></li>
                    <li><a href="https://github.com/tib/" target="_blank">GitHub</a></li>
                    <li><a href="https://x.com/tiborbodecs" target="_blank">X (Twitter)</a></li>
                    <li><a href="https://mastodon.social/@tiborbodecs" target="_blank">Mastodon</a></li>
                </ul>
            </div>
            
        </div>
        
        <section class="grid grid-221">
            <small>Swift on server &copy; 2022 - 2024</small>
            <small>This site was generated using <a href="https://swift.org/" target="_blank">Swift</a> & <a href="https://github.com/binarybirds/toucan" target="_blank">Toucan</a>.</small>
        </section>
    </footer>

    </div>

    

</body>
</html>
