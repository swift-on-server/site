<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>Structured Concurrency and Shared State in Swift - Swift on Server</title>

        <meta name="description" content="Learn how actors and sendable prevent race conditions in your concurrent code." />

        <meta property="og:title" content="Structured Concurrency and Shared State in Swift - Swift on Server" />
        <meta property="og:description" content="Learn how actors and sendable prevent race conditions in your concurrent code." />
        <meta property="og:url" content="https://swiftonserver.com/structured-concurrency-and-shared-state-in-swift/" />
        <meta property="og:image" content="https://swiftonserver.com/images/assets/structured-concurrency-and-shared-state-in-swift/cover.jpg" />

        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="Structured Concurrency and Shared State in Swift - Swift on Server" />
        <meta name="twitter:description" content="Learn how actors and sendable prevent race conditions in your concurrent code." />
        <meta name="twitter:image" content="https://swiftonserver.com/images/assets/structured-concurrency-and-shared-state-in-swift/cover.jpg" />

        <link rel="stylesheet" href="https://swiftonserver.com/css/style.css" />
        <link rel="stylesheet" href="https://swiftonserver.com/css/syntax.css" />

        <link rel="shortcut icon" href="https://swiftonserver.com/images/icons/favicon.ico" type="image/x-icon" />
        <link rel="shortcut icon" href="https://swiftonserver.com/images/icons/icon-320.png" type="image/png" />

        <script type="text/javascript" src="https://swiftonserver.com/js/tooltips.js" async></script>

        <link rel="apple-touch-icon" href="https://swiftonserver.com/images/icons/apple-touch-icon.png" />
        <link rel="apple-touch-icon" sizes="57x57" href="https://swiftonserver.com/images/icons/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="https://swiftonserver.com/images/icons/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon" sizes="76x76" href="https://swiftonserver.com/images/icons/apple-touch-icon-76x76.png" />
        <link rel="apple-touch-icon" sizes="114x114" href="https://swiftonserver.com/images/icons/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon" sizes="120x120" href="https://swiftonserver.com/images/icons/apple-touch-icon-120x120.png" />
        <link rel="apple-touch-icon" sizes="144x144" href="https://swiftonserver.com/images/icons/apple-touch-icon-144x144.png" />
        <link rel="apple-touch-icon" sizes="152x152" href="https://swiftonserver.com/images/icons/apple-touch-icon-152x152.png" />
        <link rel="apple-touch-icon" sizes="180x180" href="https://swiftonserver.com/images/icons/apple-touch-icon-180x180.png" />

    </head>

    <body>
        <header id="page-header">
            <a href="https://swiftonserver.com/">
                <figure>
                    <picture>
                        <source
                        srcset="https://swiftonserver.com/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                        />
                        <img
                        id="logo-image"
                        width="150"
                        height="150"
                        src="https://swiftonserver.com/images/logos/logo.png"
                        alt="Logo of Swift on server"
                        title="Swift on server"
                        />
                    </picture>
                </figure>
            </a>
        </header>

        <main>

            <article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2024/03/25">2024/03/25</time>
            <h1 class="title">Structured Concurrency and Shared State in Swift</h1>
            <p class="excerpt">Learn how actors and sendable prevent race conditions in your concurrent code.</p>
            <div class="meta">
                <span class="tag">Swift</span>
                <span class="tag">Structured Concurrency</span>
            </div>
            <img src="https://github.com/joannis.png" alt="Joannis Orlandos" class="author">
            <p>
                <span class="author">Written by: <a href="https://x.com/JoannisOrlandos" target="_blank">Joannis Orlandos</a> @ 
                <span class="author"><a href="https://unbeatable.software/" target="_blank">Unbeatable Software B.V.</a></span><br>
                <span class="reading-time">Reading time: 30 minutes</span><br>
            </p>
        </section>
    </header>

    <section class="content-wrapper">
        <hr>
    </section>

    <section id="contents" class="content-wrapper">
    
    <section class='introduction'><h1>Sendable and Shared Mutable State</h1></section><section class='details literature'><p>When working with concurrent code, you’ll often need to share state between tasks. Using reference types such as a <code>class</code> allows you to share state between different threads and tasks. This can lead to race conditions where two tasks are trying to access the same state at the same time.</p><p>The Thread Sanitizer in Xcode can help you find race conditions. It’s better to avoid them altogether. You can do so by adopting the <code><a href='https://swiftinit.org/docs/swift/swift/sendable'>Sendable</a></code> protocol on your types. This protocol is used to mark types that can be safely sent between tasks.</p><p>If the compiler is able to determine that a type is Sendable, the conformance does not require additional work. In other cases, you’ll need to provide the conformance yourself.</p><p>Sendability is a contract, initiated by the type, that the type is safe to be sent between tasks. Structs and enums are automatically Sendable, if all of their properties are Sendable. Since value types are copied when they are sent between tasks, you can safely send a struct or enum between tasks, and you don’t have to worry about race conditions.</p><h3 id='Classes'><a href='#Classes'>Classes</a></h3><p>Classes are not automatically Sendable. Since reference types are explicitly not copied but referenced, you can’t safely send a class between tasks. You can mark a class as Sendable if all of its properties are marked <code><a href='https://swiftinit.org/docs/swift/swift/sendable'>Sendable</a></code> and a constant (let).</p><p>If you’re working with a class that is not a set of constants, you can still mark it as Sendable by using the <code>@unchecked Sendable</code> conformance. When you use this conformance, you’re telling the compiler that you’re sure that the class is Sendable, and that you’re taking responsibility of isolating the state. In this case, you can adopt your own isolation such as Locks.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>final</span> <span class='xk'>class</span> <span class='xv'>SharedState</span>: <span class='xa'>@unchecked</span> <span class='xt'>Sendable</span> {<span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>var</span> <span class='xv'>_state</span>: <span class='xt'>Int</span> = <span class='xn'>0</span><span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>lock</span> = <span class='xv'>NSLock</span>()<span class='newline'>
</span>    <span class='xk'>public</span> <span class='xk'>var</span> <span class='xv'>state</span>: <span class='xt'>Int</span> {<span class='newline'>
</span>        <span class='xk'>get</span> {<span class='newline'>
</span>            <span class='xv'>lock</span>.<span class='xv'>withLock</span> { <span class='xv'>_state</span> }<span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='xk'>set</span> {<span class='newline'>
</span>            <span class='xv'>lock</span>.<span class='xv'>withLock</span> { <span class='xv'>_state</span> = <span class='xv'>newValue</span> }<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><h3 id='Actors%20and%20Isolation'><a href='#Actors%20and%20Isolation'>Actors and Isolation</a></h3><p>Isolation is a way to ensure that only one task can access a piece of state at a time. This is done by using locks, or by using Swift’s new <code>actor</code> type. When you’re using a lock, you’re responsible for ensuring that the lock is used correctly. This means that you need to lock the state before accessing it, and unlock it after you’re done.</p><p>The easier and new way to share state between tasks is using an <code>actor</code>. An actor is a reference type, like classes, that is automatically Sendable. Unlike classes, actors do not support inheritance.</p><p>Actors achieve Sendable support by only allowing access from the actor’s own <em>isolated</em> context. Reading values and calling methods on an actor is forced by the compiler to happen in that isolated context.</p><p>When accessing an actor’s state or calling its functions, you can prefix your call with <code>async</code>, if you’re not doing so already. The compiler will enforce that only one thread is accessing the actor’s state at a time, and suspend until the actor is available.</p><p>You can define an actor like so:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>actor</span> <span class='xv'>BankAccount</span> {<span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>balance</span>: <span class='xt'>Int</span> = <span class='xn'>0</span><span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>deposit</span>(_ <span class='xv'>amount</span>: <span class='xt'>Int</span>) {<span class='newline'>
</span>        <span class='xv'>balance</span> <span class='xo'>+=</span> <span class='xv'>amount</span><span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>withdraw</span>(_ <span class='xv'>amount</span>: <span class='xt'>Int</span>) {<span class='newline'>
</span>        <span class='xv'>balance</span> <span class='xo'>-=</span> <span class='xv'>amount</span><span class='newline'>
</span>    }<span class='newline'>
</span>}<span class='newline'>

</span><span class='xk'>let</span> <span class='xv'>bankAccount</span> = <span class='xv'>BankAccount</span>()<span class='newline'>
</span><span class='xk'>await</span> <span class='xv'>bankAccount</span>.<span class='xv'>deposit</span>(<span class='xn'>100</span>)<span class='newline'>
</span><span class='xk'>let</span> <span class='xv'>balance</span> = <span class='xk'>await</span> <span class='xv'>bankAccount</span>.<span class='xv'>balance</span><span class='newline'>
</span><span class='xv'>print</span>(<span class='xv'>balance</span>) <span class='xc'>// 100</span></code></pre><p>Just like any type, you can make an <code>extension</code> on an actor. Actors can also conform to protocols, assuming that the protocol’s signature can be feasibly implemented with isolation. A common obstacle is that you can’t easily conform to a protocol that has properties or methods that are not isolated.</p><p>An actor’s isolation is inherited by its properties and methods. Actor Isolation is compile-time checked to ensures that only one task can access the actor’s state at a time. This is achieved through the <code><a href='https://swiftinit.org/docs/swift/_concurrency/actor.unownedexecutor'>unownedExecutor</a></code> of an actor. This is a <code><a href='https://swiftinit.org/docs/swift/_concurrency/serialexecutor'>SerialExecutor</a></code> that the Swift runtime submits tasks to, which provides the isolation in this actor. The SerialExecutor may be a single thread, or multiple. But needs to guarantee that only one task is running on this at a time. Akin to <code>DispatchQueue.main.async { }</code> in GCD.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xv'>bankAccount</span>.<span class='xv'>unownedExecutor</span></code></pre><p>You can create your own <code><a href='https://swiftinit.org/docs/swift/_concurrency/serialexecutor'>SerialExecutor</a></code> for use with your actors. SwiftNIO’s EventLoop already has a <code><a href='https://swiftinit.org/docs/swift-nio/niocore/eventloop.executor?hash=59PH6'>executor</a></code> property that you can use. <code><a href='https://swiftinit.org/docs/swift/dispatch'>Dispatch</a></code>’s <code><a href='https://swiftinit.org/docs/swift/dispatch/dispatchqueue'>DispatchQueue</a></code> can be adapted easily as well.</p><p>Since <code><a href='https://swiftinit.org/docs/swift/_concurrency/actor.unownedexecutor'>unownedExecutor</a></code> is not a static member of an actor, an actor’s static properties can <em>not be isolated</em> by the actor.</p><h3 id='Nonisolated'><a href='#Nonisolated'>Nonisolated</a></h3><p>You can use the <code>nonisolated</code> keyword to mark a function as lacking isolation. This allows you to access these functions without the <code>await</code> keyword, and conform to protocols that have non-isolated methods.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>actor</span> <span class='xv'>BookStore</span>: <span class='xt'>AsyncSequence</span> {<span class='newline'>
</span>    <span class='xk'>typealias</span> <span class='xv'>AsyncIterator</span> = <span class='xt'>AsyncStream</span>&lt;<span class='xt'>Book</span>&gt;.<span class='xt'>AsyncIterator</span><span class='newline'>
</span>    <span class='xk'>typealias</span> <span class='xv'>Element</span> = <span class='xt'>Book</span><span class='newline'>

</span>    <span class='xk'>private</span> <span class='xk'>var</span> <span class='xv'>page</span> = <span class='xn'>1</span><span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>var</span> <span class='xv'>hasReachedEnd</span> = <span class='xk'>false</span><span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>let</span> <span class='xv'>stream</span>: <span class='xt'>AsyncStream</span>&lt;<span class='xt'>Book</span>&gt;<span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>let</span> <span class='xv'>continuation</span>: <span class='xt'>AsyncStream</span>&lt;<span class='xt'>Book</span>&gt;.<span class='xt'>Continuation</span><span class='newline'>

</span>    <span class='xk'>init</span>() {<span class='newline'>
</span>        (<span class='xv'>stream</span>, <span class='xv'>continuation</span>) = <span class='xv'>AsyncStream</span>&lt;<span class='xt'>Book</span>&gt;.<span class='xv'>makeStream</span>(<span class='newline'>
</span>            <span class='xv'>bufferingPolicy</span>: .<span class='xv'>unbounded</span><span class='newline'>
</span>        )<span class='newline'>
</span>    }<span class='newline'>
</span>    <span class='newline'>
</span>    <span class='xk'>func</span> <span class='xv'>produce</span>() <span class='xk'>async</span> <span class='xk'>throws</span> {<span class='newline'>
</span>        <span class='xk'>do</span> {<span class='newline'>
</span>           <span class='xk'>while</span> <span class='xo'>!</span><span class='xv'>hasReachedEnd</span> {<span class='newline'>
</span>               <span class='xk'>let</span> <span class='xv'>books</span> = <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>fetchBooks</span>(<span class='xv'>page</span>: <span class='xv'>page</span>)<span class='newline'>
</span>               <span class='xv'>hasReachedEnd</span> = <span class='xv'>books</span>.<span class='xv'>isEmpty</span><span class='newline'>
</span>               <span class='xk'>for</span> <span class='xv'>book</span> <span class='xk'>in</span> <span class='xv'>books</span> {<span class='newline'>
</span>                   <span class='xv'>continuation</span>.<span class='xv'>yield</span>(<span class='xv'>book</span>)<span class='newline'>
</span>               }<span class='newline'>
</span>               <span class='xv'>page</span> <span class='xo'>+=</span> <span class='xn'>1</span><span class='newline'>
</span>           }<span class='newline'>
</span>           <span class='xv'>continuation</span>.<span class='xv'>finish</span>()<span class='newline'>
</span>        } <span class='xk'>catch</span> {<span class='newline'>
</span>            <span class='xv'>continuation</span>.<span class='xv'>finish</span>(<span class='xv'>throwing</span>: <span class='xv'>error</span>)<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xc'>// AsyncSequence required a nonisolated func here</span><span class='newline'>
</span>    <span class='xk'>nonisolated</span> <span class='xk'>func</span> <span class='xv'>makeAsyncIterator</span>() -&gt; <span class='xt'>AsyncIterator</span> {<span class='newline'>
</span>        <span class='xv'>stream</span>.<span class='xv'>makeAsyncIterator</span>()<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>Starting with Swift 5.10, <code>nonisolated(unsafe)</code> can be used to opt-out of actor isolation checking for stored properties. This is useful to expose a property or method to the outside world, but you’re sure that it’s safe to do so. In this case, you’re taking responsibility of isolating the state.</p><h3 id='Async%20Computed%20Properties'><a href='#Async%20Computed%20Properties'>Async Computed Properties</a></h3><p>The alternative way to conform to protocols, is for the <em>protocol</em> to be aware of the actor’s isolation. This is done by using <code>async</code> computed properties.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>protocol</span> <span class='xv'>BankAccount</span> {<span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>balance</span>: <span class='xt'>Int</span> { <span class='xk'>get</span> <span class='xk'>async</span> }<span class='newline'>
</span>    <span class='xk'>func</span> <span class='xv'>deposit</span>(_ <span class='xv'>amount</span>: <span class='xt'>Int</span>) <span class='xk'>async</span><span class='newline'>
</span>    <span class='xk'>func</span> <span class='xv'>withdraw</span>(_ <span class='xv'>amount</span>: <span class='xt'>Int</span>) <span class='xk'>async</span><span class='newline'>
</span>}<span class='newline'>

</span><span class='xk'>actor</span> <span class='xv'>MyBankAccount</span>: <span class='xt'>BankAccount</span> {<span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>balance</span>: <span class='xt'>Int</span> = <span class='xn'>0</span><span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>deposit</span>(_ <span class='xv'>amount</span>: <span class='xt'>Int</span>) {<span class='newline'>
</span>        <span class='xv'>balance</span> <span class='xo'>+=</span> <span class='xv'>amount</span><span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>withdraw</span>(_ <span class='xv'>amount</span>: <span class='xt'>Int</span>) {<span class='newline'>
</span>        <span class='xv'>balance</span> <span class='xo'>-=</span> <span class='xv'>amount</span><span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>Because actor isolation makes these functions and properties <code>async</code>, this actor can now to the defined protocol.</p><p>Actors are a powerful way to share state between tasks. There’s just one catch; Actors are “re-entrant”.</p><p>When an actor is called from within itself, it’s called re-entrant. This is important for many use cases and implementations, but it can lead to an unexpected consequence.</p><h3 id='Actor%20Re-Entrancy'><a href='#Actor%20Re-Entrancy'>Actor Re-Entrancy</a></h3><p>When isolating state with a lock, Swift guarantees that only one thread can access the state at a time. When a function calls another function on the same thread, you can run into a deadlock. This happens because second function “locks” the state again, but because it’s already locked, it waits indefinitely for the first function to unlock it.</p><p>Recursive locks are a common solution to that problem. In structured concurrency, you’ll want to avoid locks entirely. In addition to the concerns mentioned previously, locks are blocking and can lead to performance bottlenecks even when used correctly.</p><p>When an actor is called from within itself, it’s called re-entrant. Actors will not deadlock, similarly to recursive lock. This is important for many use cases and implementations, but it can lead to an unexpected consequence.</p><p>Because of re-entrancy, multiple tasks can call functions on the same actor at the same time! Actor isolation simply prevents race conditions, but does not provide a ‘queue’ for access.</p><p>Let’s take the image cache example as an actor:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>actor</span> <span class='xv'>ImageCache</span> {<span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>var</span> <span class='xv'>cache</span>: [<span class='xt'>URL</span>: <span class='xt'>UIImage</span>] = [:]<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>image</span>(<span class='xv'>for</span> <span class='xv'>url</span>: <span class='xt'>URL</span>) -&gt; <span class='xt'>UIImage</span>? {<span class='newline'>
</span>        <span class='xk'>return</span> <span class='xv'>cache</span>[<span class='xv'>url</span>]<span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>setImage</span>(_ <span class='xv'>image</span>: <span class='xt'>UIImage</span>, <span class='xv'>for</span> <span class='xv'>url</span>: <span class='xt'>URL</span>) {<span class='newline'>
</span>        <span class='xv'>cache</span>[<span class='xv'>url</span>] = <span class='xv'>image</span><span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>loadImage</span>(<span class='xv'>for</span> <span class='xv'>url</span>: <span class='xt'>URL</span>) <span class='xk'>async</span> <span class='xk'>throws</span> {<span class='newline'>
</span>        <span class='xk'>if</span> <span class='xv'>cache</span>.<span class='xv'>keys</span>.<span class='xv'>contains</span>(<span class='xv'>url</span>) {<span class='newline'>
</span>            <span class='xk'>return</span><span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>image</span> = <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>fetchImage</span>(<span class='xv'>at</span>: <span class='xv'>url</span>)<span class='newline'>
</span>        <span class='xv'>setImage</span>(<span class='xv'>image</span>, <span class='xv'>for</span>: <span class='xv'>url</span>)<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>The above function is an implementation of the image cache. It’s a simple actor that allows storing and retrieving images by URL. Since actors are re-entrant, <code>loadImage</code> can be ran multiple times concurrently. This can lead to multiple fetches of the same image, and multiple writes to the cache.</p><p>Your code can still be correct and crash-free, but can be inefficient.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>actor</span> <span class='xv'>ImageCache</span> {<span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>var</span> <span class='xv'>cache</span>: [<span class='xt'>URL</span>: <span class='xt'>UIImage</span>] = [:]<span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>var</span> <span class='xv'>loadingURLs</span>: <span class='xt'>Set</span>&lt;<span class='xt'>URL</span>&gt; = []<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>image</span>(<span class='xv'>for</span> <span class='xv'>url</span>: <span class='xt'>URL</span>) -&gt; <span class='xt'>UIImage</span>? {<span class='newline'>
</span>        <span class='xk'>return</span> <span class='xv'>cache</span>[<span class='xv'>url</span>]<span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>setImage</span>(_ <span class='xv'>image</span>: <span class='xt'>UIImage</span>, <span class='xv'>for</span> <span class='xv'>url</span>: <span class='xt'>URL</span>) {<span class='newline'>
</span>        <span class='xv'>cache</span>[<span class='xv'>url</span>] = <span class='xv'>image</span><span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>loadImage</span>(<span class='xv'>for</span> <span class='xv'>url</span>: <span class='xt'>URL</span>) <span class='xk'>async</span> <span class='xk'>throws</span> {<span class='newline'>
</span>        <span class='xk'>if</span> <span class='xv'>cache</span>.<span class='xv'>keys</span>.<span class='xv'>contains</span>(<span class='xv'>url</span>), <span class='xo'>!</span><span class='xv'>loadingURLs</span>.<span class='xv'>contains</span>(<span class='xv'>url</span>) {<span class='newline'>
</span>            <span class='xk'>return</span><span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='newline'>
</span>        <span class='xv'>loadingURLs</span>.<span class='xv'>insert</span>(<span class='xv'>url</span>)<span class='newline'>
</span>        <span class='xk'>defer</span> { <span class='xv'>loadingURLs</span>.<span class='xv'>remove</span>(<span class='xv'>url</span>) }<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>image</span> = <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>fetchImage</span>(<span class='xv'>at</span>: <span class='xv'>url</span>)<span class='newline'>
</span>        <span class='xv'>setImage</span>(<span class='xv'>image</span>, <span class='xv'>for</span>: <span class='xv'>url</span>)<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>The above function is an improved implementation of the image cache. By tracking the URLs that are currently being loaded, you can avoid fetching the same image multiple times.</p><p>While actors are re-entrant, we can safely access and modify state in sequence <em>until</em> we hit a suspension point.</p><p>The <code>await</code> keyword is the syntactical equivalent of a <em>possible</em> suspension point. The function doesn’t <em>need</em> to suspend, but one should always assume that it <em>can</em> suspend. This is especially important when working with actors.</p><p>Inbetween suspension points, this function is the only <em>currently</em> running code on the actor. This means that you can safely access and modify state without worry.</p><h3 id='Capture%20Groups'><a href='#Capture%20Groups'>Capture Groups</a></h3><p>Now that you know about Sendable and actors, you might be wondering why only <em>some</em> functions are Sendable.</p><p>When passing a callback to a function, it is marked as <code>@escaping</code>. This means Swift knows that the function can be stored. It can be called at any point, and possibly even multiple times! The properties that this function need to exist by the time that the escaping closure function is called.</p><p>When a callback is accessing properties on <code>self</code>, the compiler will emit a retain on <code>self</code>. Because implicitly capturing <code>self</code> can lead to unintentionally prolonged lifetimes, Swift requires you to explicitly access these properties as such:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>final</span> <span class='xk'>class</span> <span class='xv'>NeedsImage</span> {<span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>result</span>: <span class='xt'>Result</span>&lt;<span class='xt'>Image</span>, <span class='xt'>Error</span>&gt;?<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>fetch</span>() {<span class='newline'>
</span>        <span class='xv'>fetchImage</span>(<span class='xv'>at</span>: <span class='xo'>...</span>) { <span class='xv'>fetchedImage</span> <span class='xk'>in</span><span class='newline'>
</span>            <span class='xc'>// Note that we have to *explicitly* add `self.`</span><span class='newline'>
</span>            <span class='xk'>self</span>.<span class='xv'>result</span> = <span class='xv'>fetchedImage</span><span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>“Escaping” in this context refers to the function escaping the scope in which it was defined. The values that this function accesses are usually implicitly <em>captured</em>. If they’re a reference type, they emit a retain. Likewise, when this function is no longer stored, it emits a release.</p><p>By explicitly creating a capture group, you’ll only retain the values needed. See the following example:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>let</span> (<span class='xv'>stream</span>, <span class='xv'>continuation</span>) = <span class='xv'>AsyncThrowingStream</span>&lt;<span class='xt'>UIImage</span>&gt;.<span class='xv'>makeStream</span>(<span class='newline'>
</span>    <span class='xv'>bufferingPolicy</span>: .<span class='xv'>unbounded</span><span class='newline'>
</span>)<span class='newline'>

</span><span class='xc'>// Hypothetical function that lists images</span><span class='newline'>
</span><span class='xc'>// Calls the callback once for each image found</span><span class='newline'>
</span><span class='xv'>findImages</span> { [<span class='xv'>continuation</span>] <span class='xv'>image</span> <span class='xk'>in</span><span class='newline'>
</span>    <span class='xc'>// Captures `continuation`</span><span class='newline'>
</span>    <span class='xv'>continuation</span>.<span class='xv'>yield</span>(<span class='xv'>image</span>)<span class='newline'>
</span>} <span class='xv'>onCompletion</span>: { [<span class='xv'>continuation</span>] <span class='xv'>error</span> <span class='xk'>in</span><span class='newline'>
</span>    <span class='xc'>// Captures `continuation`</span><span class='newline'>
</span>    <span class='xc'>// Called exactly once when done or failed</span><span class='newline'>
</span>    <span class='xk'>if</span> <span class='xk'>let</span> <span class='xv'>error</span> = <span class='xv'>error</span> {<span class='newline'>
</span>        <span class='xv'>continuation</span>.<span class='xv'>finish</span>(<span class='xv'>throwing</span>: <span class='xv'>error</span>)<span class='newline'>
</span>    } <span class='xk'>else</span> {<span class='newline'>
</span>        <span class='xv'>continuation</span>.<span class='xv'>finish</span>()<span class='newline'>
</span>    }<span class='newline'>
</span>}<span class='newline'>

</span><span class='xk'>for</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>image</span> <span class='xk'>in</span> <span class='xv'>stream</span> {<span class='newline'>
</span>    <span class='xc'>// Show image</span><span class='newline'>
</span>}</code></pre><h3 id='@Sendable%20Functions'><a href='#@Sendable%20Functions'>@Sendable Functions</a></h3><p>When marking functions as <code>@Sendable</code>, you’re telling Swift that the function is safe to be stored and called across actor boundaries and is thread-safe. Swift will enforce that the function is not accessing any state that is not Sendable.</p><p>Callback function arguments can be makred <code>@Sendable</code> as such:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>func</span> <span class='xv'>fetchImage</span>(<span class='xv'>at</span> <span class='xv'>url</span>: <span class='xt'>URL</span>, <span class='xv'>completion</span>: <span class='xa'>@Sendable</span> <span class='xa'>@escaping</span> (<span class='xt'>Result</span>&lt;<span class='xt'>UIImage</span>, <span class='xt'>Error</span>&gt;) -&gt; <span class='xt'>Void</span>) {<span class='newline'>
</span>    <span class='xo'>...</span><span class='newline'>
</span>}</code></pre><p>Finally, regular functions can be marked <code>@Sendable</code> as well:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xa'>@Sendable</span> <span class='xk'>func</span> <span class='xv'>fetchImage</span>(<span class='xv'>at</span> <span class='xv'>url</span>: <span class='xt'>URL</span>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>UIImage</span> {<span class='newline'>
</span>    <span class='xo'>...</span><span class='newline'>
</span>}</code></pre><h2 id='Continuations'><a href='#Continuations'>Continuations</a></h2><p>So far, we’ve been using <code>await</code> to wait for a value to be available. But not all APIs are designed to work with <code>async</code> and <code>await</code>. When using APIs that were designed before concurrency, “continuations” can bridge the gap.</p><p>A continuation is a way to capture the current state of a task, and to resume the task at a later point. Let’s implement a simple continuation that fetches an image:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xa'>@Sendable</span> <span class='xk'>func</span> <span class='xv'>fetchImage</span>(<span class='xv'>at</span> <span class='xv'>url</span>: <span class='xt'>URL</span>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>UIImage</span> {<span class='newline'>
</span>    <span class='xk'>return</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>withCheckedThrowingContinuation</span> { <span class='xv'>continuation</span> <span class='xk'>in</span><span class='newline'>
</span>        <span class='xv'>fetchImage</span>(<span class='xv'>at</span>: <span class='xv'>url</span>) { <span class='xv'>result</span> <span class='xk'>in</span><span class='newline'>
</span>            <span class='xk'>switch</span> <span class='xv'>result</span> {<span class='newline'>
</span>            <span class='xk'>case</span> .<span class='xv'>success</span>(<span class='xk'>let</span> <span class='xv'>image</span>):<span class='newline'>
</span>                <span class='xv'>continuation</span>.<span class='xv'>resume</span>(<span class='xv'>returning</span>: <span class='xv'>image</span>)<span class='newline'>
</span>            <span class='xk'>case</span> .<span class='xv'>failure</span>(<span class='xk'>let</span> <span class='xv'>error</span>):<span class='newline'>
</span>                <span class='xv'>continuation</span>.<span class='xv'>resume</span>(<span class='xv'>throwing</span>: <span class='xv'>error</span>)<span class='newline'>
</span>            }<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>There are two variations of continuations.</p><p>A <code><a href='https://swiftinit.org/docs/swift/_concurrency/checkedcontinuation'>CheckedContinuation</a></code> is a continuation that checks for correct use. Continuations <strong>must</strong> be resumed exactly once. If you don’t resume the continuation or if you resume it more than once, your application will crash. This is a safety feature to prevent worse problems from happening.</p><p>In contrast, an <code><a href='https://swiftinit.org/docs/swift/_concurrency/unsafecontinuation'>UnsafeContinuation</a></code> is a continuation that doesn’t check for correct use. If you resume the continuation multiple times, or if you don’t resume it at all, you’ll be sure to run into undefined behaviour - leading to a variety of hard-to-debug problems. However, unsafe continuations can be useful in <em>extremely</em> performance-sensitive code.</p><p>Continuations can be throwing or non-throwing, for example:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>await</span> <span class='xv'>withCheckedContination</span> { <span class='xv'>continuation</span> <span class='xk'>in</span><span class='newline'>
</span>    <span class='xc'>// Asynchronous work that does not fail</span><span class='newline'>
</span>}</code></pre><p>Continuations will suspend the task until they’re resumed. While continuations are great for bridging the gap between async and non-async code, they’re also very useful in other cases when using structured concurrency.</p><p>Let’s go back to the ImageCache example. In that example, the <code>loadImage</code> function fetches an image and stores it in the cache. In this case, it does not return the cached image, making the API very unpractical!</p><p>We can restructure the <code>loadImage</code> function to use a continuation:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>final</span> <span class='xk'>class</span> <span class='xv'>ImageCache</span> {<span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>var</span> <span class='xv'>cache</span>: [<span class='xt'>URL</span>: <span class='xt'>UIImage</span>] = [:]<span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>var</span> <span class='xv'>loadingURLs</span>: <span class='xt'>Set</span>&lt;<span class='xt'>URL</span>&gt; = []<span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>var</span> <span class='xv'>fetchingURLs</span>: [(<span class='xt'>URL</span>, <span class='xt'>CheckedContinuation</span>&lt;<span class='xt'>UIImage</span>, <span class='xt'>Error</span>&gt;)] = []<span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>func</span> <span class='xv'>completeFetchingURLs</span>(<span class='xv'>with</span> <span class='xv'>result</span>: <span class='xt'>Result</span>&lt;<span class='xt'>UIImage</span>, <span class='xt'>Error</span>&gt;, <span class='xv'>for</span> <span class='xv'>url</span>: <span class='xt'>URL</span>) {<span class='newline'>
</span>        <span class='xk'>for</span> (<span class='xv'>awaitingURL</span>, <span class='xv'>continuation</span>) <span class='xk'>in</span> <span class='xv'>fetchingURLs</span> <span class='xk'>where</span> <span class='xv'>awaitingURL</span> <span class='xo'>==</span> <span class='xv'>url</span> {<span class='newline'>
</span>            <span class='xk'>switch</span> <span class='xv'>result</span> {<span class='newline'>
</span>            <span class='xk'>case</span> .<span class='xv'>success</span>(<span class='xk'>let</span> <span class='xv'>image</span>):<span class='newline'>
</span>                <span class='xv'>continuation</span>.<span class='xv'>resume</span>(<span class='xv'>returning</span>: <span class='xv'>image</span>)<span class='newline'>
</span>            <span class='xk'>case</span> .<span class='xv'>failure</span>(<span class='xk'>let</span> <span class='xv'>error</span>):<span class='newline'>
</span>                <span class='xv'>continuation</span>.<span class='xv'>resume</span>(<span class='xv'>throwing</span>: <span class='xv'>error</span>)<span class='newline'>
</span>            }<span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='xv'>fetchingURLs</span>.<span class='xv'>removeAll</span> { <span class='xp'>$0</span>.<span class='xn'>0</span> <span class='xo'>==</span> <span class='xv'>url</span> }<span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>loadImage</span>(<span class='xv'>at</span> <span class='xv'>url</span>: <span class='xt'>URL</span>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>UIImage</span> {<span class='newline'>
</span>        <span class='xk'>if</span> <span class='xk'>let</span> <span class='xv'>image</span> = <span class='xv'>cache</span>[<span class='xv'>url</span>] {<span class='newline'>
</span>            <span class='xk'>return</span> <span class='xv'>image</span><span class='newline'>
</span>        }<span class='newline'>

</span>        <span class='xk'>if</span> <span class='xv'>loadingURLs</span>.<span class='xv'>contains</span>(<span class='xv'>url</span>) {<span class='newline'>
</span>            <span class='xk'>return</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>withCheckedThrowingContinuation</span> { <span class='xv'>continuation</span> <span class='xk'>in</span><span class='newline'>
</span>                <span class='xv'>fetchingURLs</span>.<span class='xv'>append</span>((<span class='xv'>url</span>, <span class='xv'>continuation</span>))<span class='newline'>
</span>            }<span class='newline'>
</span>        }<span class='newline'>

</span>        <span class='xv'>loadingURLs</span>.<span class='xv'>insert</span>(<span class='xv'>url</span>)<span class='newline'>
</span>        <span class='xk'>defer</span> { <span class='xv'>loadingURLs</span>.<span class='xv'>remove</span>(<span class='xv'>url</span>) }<span class='newline'>
</span>        <span class='newline'>
</span>        <span class='xk'>do</span> {<span class='newline'>
</span>            <span class='xk'>let</span> <span class='xv'>image</span> = <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>fetchImage</span>(<span class='xv'>at</span>: <span class='xv'>url</span>)<span class='newline'>
</span>            <span class='xv'>setImage</span>(<span class='xv'>image</span>, <span class='xv'>for</span>: <span class='xv'>url</span>)<span class='newline'>
</span>            <span class='xv'>completeFetchingURLs</span>(<span class='xv'>with</span>: .<span class='xv'>success</span>(<span class='xv'>image</span>), <span class='xv'>for</span>: <span class='xv'>url</span>)<span class='newline'>
</span>            <span class='xk'>return</span> <span class='xv'>image</span><span class='newline'>
</span>        } <span class='xk'>catch</span> {<span class='newline'>
</span>            <span class='xv'>completeFetchingURLs</span>(<span class='xv'>with</span>: .<span class='xv'>failure</span>(<span class='xv'>error</span>), <span class='xv'>for</span>: <span class='xv'>url</span>)<span class='newline'>
</span>            <span class='xk'>throw</span> <span class='xv'>error</span><span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p><strong>Note:</strong> When creating a continuation, you’re starting a new workload that does not (yet) adopt structured concurrency. When this happens, this code is also responsible for ensuring that Task Cancellation is handled propertly. For that, please refer back to <code>withTaskCancellationHandler</code> earlier in this article.</p><h2 id='Global%20Actors'><a href='#Global%20Actors'>Global Actors</a></h2><p>We’ve seen actors being used to isolate state and to share state between tasks. Global actors are singleton-actors that isolate state outside of their type. This allows global actors to be used to isolate state in a global context, such as static members or static functions.</p><p>The most commonly known and used global actor is the <code><a href='https://swiftinit.org/docs/swift/_concurrency/mainactor'>MainActor</a></code>. This actor is used to isolate state on the main thread, and is commonly used on iOS to ensure that UI updates and relevant state changes are done on the main thread.</p><p>You can use the <code>@MainActor</code> attribute to mark a property as being isolated to the main actor:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xa'>@MainActor</span> <span class='xk'>var</span> <span class='xv'>view</span>: <span class='xt'>UIView</span></code></pre><p>Functions can also apply the <code><a href='https://swiftinit.org/docs/swift/_concurrency/mainactor'>MainActor</a></code> by marking it as shown here:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xc'>// MainActor isolated</span><span class='newline'>
</span><span class='xa'>@MainActor</span> <span class='xk'>func</span> <span class='xv'>updateUI</span>() {<span class='newline'>
</span>    <span class='xc'>// Update the UI</span><span class='newline'>
</span>    <span class='xc'>// Accessing `view` is safe, and does not need `await`</span><span class='newline'>
</span>    <span class='xc'>// Because both share the same actor's isolation</span><span class='newline'>
</span>    <span class='xv'>view</span>.<span class='xv'>backgroundColor</span> = .<span class='xv'>red</span><span class='newline'>
</span>}</code></pre><p>When applying a global actor, the values and/or functions are isolated to this actor. This means that any isolated state can only be accessed from within the same actor’s isolation, and you’ll need to <code>await</code> getting the actor’s state from outside of the actor. In addition, state cannot be <em>modified</em> outside of the actor’s isolation.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xc'>// Not a `MainActor` isolated function</span><span class='newline'>
</span><span class='xk'>func</span> <span class='xv'>rerenderUI</span>(<span class='xv'>every</span> <span class='xv'>duration</span>: <span class='xt'>Duration</span>) <span class='xk'>async</span> <span class='xk'>throws</span> {<span class='newline'>
</span>    <span class='xc'>// Within this nonisolated function, `view` may not be modified</span><span class='newline'>
</span>    <span class='xk'>while</span> <span class='xk'>true</span> {<span class='newline'>
</span>        <span class='xc'>// Can get cancelled</span><span class='newline'>
</span>        <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>Task</span>.<span class='xv'>sleep</span>(<span class='xv'>for</span>: <span class='xv'>duration</span>)<span class='newline'>

</span>        <span class='xc'>// `updateUI` is MainActor isolated</span><span class='newline'>
</span>        <span class='xc'>// Since this function is not isolated to @MainActor, we need to `await` the call</span><span class='newline'>
</span>        <span class='xk'>await</span> <span class='xv'>updateUI</span>()<span class='newline'>
</span>        <span class='xc'>// `view` is MainActor isolated, so needs to be `await`ed</span><span class='newline'>
</span>        <span class='xv'>print</span>(<span class='xk'>await</span> <span class='xv'>view</span>.<span class='xv'>backgroundColor</span>)<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>When calling an <code>async</code> function from an <em>isolated</em> context such as the <em>MainActor</em>, isolation is <em>not</em> inherited. Swift will use the global concurrent executor to run this function, instead of the executor specified by the (global) actor.</p><p>This frees up the actor to continue processing other tasks, and prevents the actor from being blocked by a long-running task. Freeing up the <code><a href='https://swiftinit.org/docs/swift/_concurrency/mainactor'>MainActor</a></code> is helpful, as it ensures that the UI remains responsive. However, this is also the reason why <em>actor re-entrancy</em> happens!</p><h3 id='Creating%20a%20Global%20Actor'><a href='#Creating%20a%20Global%20Actor'>Creating a Global Actor</a></h3><p>Custom global actors can be created through the <code>@globalActor</code> attribute:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xa'>@globalActor</span> <span class='xk'>actor</span> <span class='xv'>SensorActor</span> {<span class='newline'>
</span>    <span class='xk'>static</span> <span class='xk'>let</span> <span class='xv'>shared</span> = <span class='xv'>SensorActor</span>()<span class='newline'>
</span>}</code></pre><p>With this addition, you can isolate properties, functions <em>and types</em> to the <code>SensorActor</code>:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>struct</span> <span class='xv'>DeviceRotation</span> {<span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>yaw</span>: <span class='xt'>Double</span><span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>pitch</span>: <span class='xt'>Double</span><span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>roll</span>: <span class='xt'>Double</span><span class='newline'>
</span>}<span class='newline'>

</span><span class='xa'>@SensorActor</span> <span class='xk'>final</span> <span class='xk'>class</span> <span class='xv'>PhoneMotionSensor</span>: <span class='xt'>AsyncSequence</span> {<span class='newline'>
</span>    <span class='xk'>typealias</span> <span class='xv'>Element</span> = <span class='xt'>DeviceRotation</span><span class='newline'>
</span>    <span class='xk'>typealias</span> <span class='xv'>AsyncIterator</span> = <span class='xt'>AsyncStream</span>&lt;<span class='xt'>DeviceRotation</span>&gt;.<span class='xt'>AsyncIterator</span><span class='newline'>

</span>    <span class='xc'>// Inherts the `SensorActor` isolation</span><span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>initial</span>: <span class='xt'>DeviceRotation</span>?<span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>let</span> <span class='xv'>continuation</span>: <span class='xt'>AsyncStream</span>&lt;<span class='xt'>DeviceRotation</span>&gt;.<span class='xt'>Continuation</span><span class='newline'>

</span>    <span class='xc'>// Opts out of the `SensorActor` isolation</span><span class='newline'>
</span>    <span class='xk'>nonisolated</span> <span class='xk'>private</span> <span class='xk'>let</span> <span class='xv'>stream</span>: <span class='xt'>AsyncStream</span>&lt;<span class='xt'>DeviceRotation</span>&gt;<span class='newline'>

</span>    <span class='xk'>init</span>() {<span class='newline'>
</span>        (<span class='xv'>stream</span>, <span class='xv'>continuation</span>) = <span class='xv'>AsyncStream</span>&lt;<span class='xt'>DeviceRotation</span>&gt;.<span class='xv'>makeStream</span>(<span class='newline'>
</span>            <span class='xv'>bufferingPolicy</span>: .<span class='xv'>unbounded</span><span class='newline'>
</span>        )<span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xc'>// Inherts the `SensorActor` isolation</span><span class='newline'>
</span>    <span class='xk'>func</span> <span class='xv'>startObserving</span>() <span class='xk'>async</span> {<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>producer</span> = <span class='xv'>SomeMotionDataProducer</span>()<span class='newline'>
</span>        <span class='xk'>for</span> <span class='xk'>await</span> <span class='xv'>rotation</span> <span class='xk'>in</span> <span class='xv'>producer</span> {<span class='newline'>
</span>            <span class='xk'>if</span> <span class='xv'>initial</span> <span class='xo'>==</span> <span class='xk'>nil</span> {<span class='newline'>
</span>                <span class='xv'>initial</span> = <span class='xv'>rotation</span><span class='newline'>
</span>            }<span class='newline'>
</span>            <span class='xv'>continuation</span>.<span class='xv'>yield</span>(<span class='xv'>rotation</span>)<span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='xv'>continuation</span>.<span class='xv'>finish</span>()<span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xc'>// Opts out of the `SensorActor` isolation</span><span class='newline'>
</span>    <span class='xk'>nonisolated</span> <span class='xk'>func</span> <span class='xv'>makeAsyncIterator</span>() -&gt; <span class='xt'>AsyncIterator</span> {<span class='newline'>
</span>        <span class='xv'>stream</span>.<span class='xv'>makeAsyncIterator</span>()<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><h2 id='Swift%206'><a href='#Swift%206'>Swift 6</a></h2><p>Starting in Swift 6, Structured Concurrency will be improved further. Even though as of writing, Swift 6 is still in development, we can already see some of the improvements that are coming. This section will be regularly updated to reflect Swift 6’s changes.</p><h3 id='Task%20Executors%20(Swift%206)'><a href='#Task%20Executors%20(Swift%206)'>Task Executors (Swift 6)</a></h3><p>Starting from Swift 6, you can specify a “task executor” to run tasks on. This is described in <a target='_blank' rel='external' href='https://github.com/apple/swift-evolution/blob/main/proposals/0417-task-executor-preference.md'>SE-0417</a>. This is especially useful for server-side Swift, where code can run within a SwiftNIO event loop (<a href='../using-swiftnio-fundamentals'>SwiftNIO Fundamentals</a>).</p><p>In Server-Side Swift, all I/O is done asynchronously on the EventLoop. By tying business logic to the same EventLoop as the I/O, you can ensure that there is no unnecessary context switching. This can lead to a significant performance improvement.</p><p>You can create a task executor by conforming to the <code>TaskExecutor</code> type. This is a part of Swift 6, and is used to run tasks on a specific executor.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>final</span> <span class='xk'>class</span> <span class='xv'>EventLoopExecutor</span>: <span class='xt'>TaskExecutor</span>, <span class='xt'>SerialExecutor</span> {<span class='newline'>
</span>    <span class='xa'>@usableFromInline</span> <span class='xk'>let</span> <span class='xv'>eventLoop</span>: <span class='xt'>EventLoop</span><span class='newline'>

</span>    <span class='xk'>init</span>(<span class='xv'>eventLoop</span>: <span class='xt'>EventLoop</span>) {<span class='newline'>
</span>        <span class='xk'>self</span>.<span class='xv'>eventLoop</span> = <span class='xv'>eventLoop</span><span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>asUnownedTaskExecutor</span>() -&gt; <span class='xt'>UnownedTaskExecutor</span> {<span class='newline'>
</span>        <span class='xv'>UnownedTaskExecutor</span>(<span class='xv'>ordinary</span>: <span class='xk'>self</span>)<span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xa'>@inlinable</span><span class='newline'>
</span>    <span class='xk'>func</span> <span class='xv'>enqueue</span>(_ <span class='xv'>job</span>: <span class='xk'>consuming</span> <span class='xt'>ExecutorJob</span>) {<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>job</span> = <span class='xv'>UnownedJob</span>(<span class='xv'>job</span>)<span class='newline'>
</span>        <span class='xv'>eventLoop</span>.<span class='xv'>execute</span> {<span class='newline'>
</span>            <span class='xv'>job</span>.<span class='xv'>runSynchronously</span>(<span class='xv'>on</span>: <span class='xk'>self</span>.<span class='xv'>asUnownedTaskExecutor</span>())<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xa'>@inlinable</span><span class='newline'>
</span>    <span class='xk'>func</span> <span class='xv'>asUnownedSerialExecutor</span>() -&gt; <span class='xt'>UnownedSerialExecutor</span> {<span class='newline'>
</span>        <span class='xv'>UnownedSerialExecutor</span>(<span class='xv'>complexEquality</span>: <span class='xk'>self</span>)<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>Now, when running a task, you can specify the executor to run the task on when you’re adding it to a task group:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>let</span> <span class='xv'>executor</span> = <span class='xv'>EventLoopExecutor</span>(<span class='xv'>eventLoop</span>: <span class='xv'>value</span>.<span class='xv'>eventLoop</span>)<span class='newline'>
</span><span class='xk'>let</span> <span class='xv'>unmanaged</span> = <span class='xv'>Unmanaged</span>.<span class='xv'>passRetained</span>(<span class='xv'>executor</span>)<span class='newline'>
</span><span class='xv'>taskGroup</span>.<span class='xv'>addTask</span>(<span class='xv'>executorPreference</span>: <span class='xv'>executor</span>) {<span class='newline'>
</span>    <span class='xk'>await</span> <span class='xv'>handle</span>(<span class='xv'>value</span>: <span class='xv'>value</span>, <span class='xv'>logger</span>: <span class='xv'>logger</span>)<span class='newline'>
</span>    <span class='xv'>unmanaged</span>.<span class='xv'>release</span>()<span class='newline'>
</span>}</code></pre><p>As you may notice, the <code>EventLoopExecutor</code> type is <em>manually</em> retained and released. This is because the <code><a href='https://swiftinit.org/docs/swift/_concurrency/taskgroup'>TaskGroup</a>.<a href='https://swiftinit.org/docs/swift/_concurrency/taskgroup.addtask(priority:operation:)'>addTask(priority:operation:)</a></code> method does not retain the executor. If the EventLoopExecutor type is not retained elsewhere, it will be deallocated before the task is done running, causing a crash.</p><h4 id='Running%20Heavy%20Workloads'><a href='#Running%20Heavy%20Workloads'>Running Heavy Workloads</a></h4><p>Previously, we wrote that large workloads should be run outside of structured concurrency. This is necessary, since the <em>standard</em> executor in Swift is designed to run tasks concurrently. In Swift 6, this is executor is the <code>globalConcurrentExecutor</code>, which is hidden in previous versions of Swift.</p><p>However, heavy workload <em>can</em> be run on a custom executor. Using the pattern shown above, or an executor that is could be provided by SwiftNIO in the future, heavy workloads can run on a custom executor that is designed to handle heavy workloads.</p></section><div style='display: none;' id='ss:tooltips'><a href='/docs/swift/swift/sendable'><pre><code><span class='xk'>protocol</span> <span class='xv'>Sendable</span></code></pre><p>A type whose values can safely be passed across concurrency domains by copying.</p></a><a href='/docs/swift/_concurrency/actor.unownedexecutor'><pre><code><span class='xk'>nonisolated</span> <span class='xk'>var</span> <span class='xv'>unownedExecutor</span>: <span class='xt'>UnownedSerialExecutor</span> { <span class='xk'>get</span> }</code></pre><p>Retrieve the executor for this actor as an optimized, unowned reference.</p></a><a href='/docs/swift/_concurrency/serialexecutor'><pre><code><span class='xk'>protocol</span> <span class='xv'>SerialExecutor</span> : <span class='xt'>Executor</span></code></pre><p>A service that executes jobs.</p></a><a href='/docs/swift-nio/niocore/eventloop.executor?hash=59PH6'><pre><code><span class='xk'>var</span> <span class='xv'>executor</span>: <span class='xk'>any</span> <span class='xt'>SerialExecutor</span> { <span class='xk'>get</span> }</code></pre><p>Returns a <code>SerialExecutor</code> corresponding to this <code>EventLoop</code>.</p></a><a href='/docs/swift/dispatch'><pre><code><span class='xk'>import</span> <span class='xv'>Dispatch</span></code></pre></a><a href='/docs/swift/dispatch/dispatchqueue'><pre><code><span class='xk'>class</span> <span class='xv'>DispatchQueue</span></code></pre></a><a href='/docs/swift/_concurrency/checkedcontinuation'><pre><code><span class='xk'>struct</span> <span class='xv'>CheckedContinuation</span>&lt;<span class='xu'>T</span>, <span class='xu'>E</span>&gt; <span class='xk'>where</span> <span class='xt'>E</span> : <span class='xt'>Error</span></code></pre><p>A mechanism to interface between synchronous and asynchronous code, logging correctness violations.</p></a><a href='/docs/swift/_concurrency/unsafecontinuation'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>UnsafeContinuation</span>&lt;<span class='xu'>T</span>, <span class='xu'>E</span>&gt; <span class='xk'>where</span> <span class='xt'>E</span> : <span class='xt'>Error</span></code></pre><p>A mechanism to interface between synchronous and asynchronous code, without correctness checking.</p></a><a href='/docs/swift/_concurrency/mainactor'><pre><code><span class='xa'>@globalActor</span> <span class='xk'>final</span> <span class='xk'>actor</span> <span class='xv'>MainActor</span></code></pre><p>A singleton actor whose executor is equivalent to the main dispatch queue.</p></a><a href='/docs/joannis.swiftonserver-site/__swiftonserver_org/using-swiftnio-fundamentals'><p>SwiftNIO is a brilliant framework that’s developed and maintained by Apple. It’s used for network application development, usually but not exclusively by libraries.</p></a><a href='/docs/swift/_concurrency/taskgroup.addtask(priority:operation:)'><pre><code><span class='xk'>mutating</span> <span class='xk'>func</span> <span class='xv'>addTask</span>(<span class='xi'></span><span class='xv'>priority</span>: <span class='xt'>TaskPriority</span>? = <span class='xk'>nil</span>, <span class='xi'></span><span class='xv'>operation</span>: <span class='xa'>@escaping</span> () <span class='xk'>async</span> -&gt; <span class='xt'>ChildTaskResult</span><wbr>)</code></pre><p>Adds a child task to the group.</p></a><a href='/docs/swift/_concurrency/taskgroup'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>TaskGroup</span>&lt;<span class='xu'>ChildTaskResult</span>&gt; <span class='xk'>where</span> <span class='xt'>ChildTaskResult</span> : <span class='xt'>Sendable</span></code></pre><p>A group that contains dynamically created child tasks.</p></a></div>
        
    </section>

    <section id="about-author" class="content-wrapper">
        <img src="https://github.com/joannis.png" alt="Joannis Orlandos" class="author">
        <h4>About Joannis Orlandos</h4>
        <p class="author-about">Joannis is a seasoned member of the Swift Server WorkGroup, and the co-founder of Unbeatable Software B.V. If you're looking to elevate your team's capabilities or need expert guidance on Swift backend development, consider hiring him.</p>

        <a href="https://unbeatable.software/mentoring-and-training" target="_blank" class="author-cta">Get in touch with Joannis</a>
    </section>
</article>


        </main>

        <footer>
            <section class="content-wrapper">
                <figure>
                    <picture>
                        <source
                        srcset="https://swiftonserver.com/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                        />
                        <img
                        id="logo-image"
                        width="80"
                        height="80"
                        src="https://swiftonserver.com/images/logos/logo.png"
                        alt="Logo of Swift on server"
                        title="Swift on server"
                        />
                    </picture>
                </figure>

                <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
                <p class="small">Created by <a href="https://x.com/JoannisOrlandos" target="_blank">Joannis Orlandos</a> & <a href="https://x.com/tiborbodecs">Tibor Bödecs</a> &copy; 2024.</p>

                <p>
                <a href="https://swiftonserver.com/">Home</a> ·
                <a href="https://swiftonserver.com/rss.xml" target="_blank">RSS</a> ·
                <a href="https://swiftonserver.com/sitemap.xml" target="_blank">Sitemap</a>
                </p>


            </section>
        </footer>
    </body>
</html>
