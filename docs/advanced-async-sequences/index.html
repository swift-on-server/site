<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="canonical" href="https://swiftonserver.com/advanced-async-sequences/">
    
    <link rel="next" href="https://swiftonserver.com/async-http-client-by-example/">

    <title>Advanced Async Sequences in Swift - Swift on server</title>
    <meta name="description" content="Learn how to use and create your own AsyncSequences.">

    <meta property="og:url" content="https://swiftonserver.com/advanced-async-sequences/">
    <meta property="og:title" content="Advanced Async Sequences in Swift - Swift on server">
    <meta property="og:description" content="Learn how to use and create your own AsyncSequences.">
    <meta property="og:image" content="/assets/advanced-async-sequences/cover.jpg" />

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Advanced Async Sequences in Swift - Swift on server">
    <meta name="twitter:description" content="Learn how to use and create your own AsyncSequences.">
    <meta name="twitter:image" content="/assets/advanced-async-sequences/cover.jpg">

    <link rel="stylesheet" href="https://swiftonserver.com/css/modern-normalize.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/modern-base.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/variables.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/base.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/grid.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/navigation.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/footer.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/syntax.css">
    <link rel="stylesheet" href="https://swiftonserver.com/css/style.css">

    

    <link rel="shortcut icon" href="https://swiftonserver.com/images/icons/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="https://swiftonserver.com/images/icons/icon-320.png" type="image/png">
    
    <link rel="apple-touch-icon" href="https://swiftonserver.com/images/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="https://swiftonserver.com/images/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://swiftonserver.com/images/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://swiftonserver.com/images/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://swiftonserver.com/images/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://swiftonserver.com/images/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://swiftonserver.com/images/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://swiftonserver.com/images/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://swiftonserver.com/images/icons/apple-touch-icon-180x180.png">

    <script type="text/javascript" src="https://swiftonserver.com//js/tooltips.js" async=""></script>

    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
        media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)">
    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css"
        media="(prefers-color-scheme: dark)"
    >

    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
          const container = document.querySelector("div#ss\\:tooltips");
          if (container !== null) {
              container.querySelectorAll('pre code').forEach((el) => {
                  el.classList.add('nohighlight');
              });
          }
        });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
          document.querySelectorAll('section pre code:not(.language-swift').forEach((el) => {
              hljs.highlightElement(el);
          });
        });
    </script>


</head>

<body>
    <div id="site-container">

    <header id="navigation">
        <a href="/">
            <figure>
                <picture>
                    <source
                        srcset="https://swiftonserver.com/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        src="https://swiftonserver.com/images/logos/logo.png"
                        alt="Logo of Swift on server"
                        title="Swift on server"
                    >
                </picture>
            </figure>
        </a>
        <nav>
            <input type="checkbox" id="primary-menu-button" name="menu-button" class="menu-button">
            <label for="primary-menu-button">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="3" y1="12" x2="21" y2="12"></line>
                    <line x1="3" y1="6" x2="21" y2="6"></line>
                    <line x1="3" y1="18" x2="21" y2="18"></line>
                </svg>
            </label>
            <div class="menu-items">
                <a href="/posts/page/1/">Posts</a>
                <a href="/tags/">Tags</a>
                <a href="/authors/">Authors</a>
                <a href="/newsletter/">Newsletter</a>
            </div>
        </nav>
    </header>

    <main id="page-container">
    
    <div class="article-with-toc">
        <div>
            <article class="post">
                <div class="meta">
                    <time datetime="2024/07/02">2024/07/02</time>
                     &middot; <span class="reading-time">15 min read</span>
                     &middot; <span class="featured">featured</span>
                </div>
                <section>
                
                <section class='introduction'><h1>Advanced Async Sequences in Swift</h1></section><section class='details literature'><p><code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence' target='_blank' rel='external'>AsyncSequence</a></code>s are very prevalent in Server-Side Swift, and are becoming more prominent in macOS and iOS apps as well.</p><p>Like other structured concurrency features, AsyncSequences enable structured programming. This makes it easier for you to reason about your code, and write more robust code free of data races.</p><p>This guide assumes familiarity with Structured Concurrency as covered in these guides:</p><ul><li><p><a href='../getting-started-with-structured-concurrency-in-swift'>Structured Concurrency in Swift</a></p></li><li><p><a href='../structured-concurrency-and-shared-state-in-swift'>Sendable and Shared Mutable State</a></p></li></ul><h2 id='What%20is%20a%20Sequence?'><a href='#What%20is%20a%20Sequence?'>What is a Sequence?</a></h2><p>Swift’s <code><a href='https://swiftinit.org/docs/swift/swift/sequence' target='_blank' rel='external'>Sequence</a></code> types are very commonly present in Swift. They provide sequential, iterated access to its elements. The most common sequence types such as <code><a href='https://swiftinit.org/docs/swift/swift/array' target='_blank' rel='external'>Array</a></code>, <code><a href='https://swiftinit.org/docs/swift/swift/set' target='_blank' rel='external'>Set</a></code> and <code><a href='https://swiftinit.org/docs/swift/swift/dictionary' target='_blank' rel='external'>Dictionary</a></code> are all a <code><a href='https://swiftinit.org/docs/swift/swift/collection' target='_blank' rel='external'>Collection</a></code>.</p><p>These Collection types can accessed by subscript, by providing an Index. The type of Index varies between implementations. A common example is the <code><a href='https://swiftinit.org/docs/swift/swift/int' target='_blank' rel='external'>Int</a></code> index used to access an <code><a href='https://swiftinit.org/docs/swift/swift/array' target='_blank' rel='external'>Array</a></code>.</p><p>Whereas <code><a href='https://swiftinit.org/docs/swift/swift/collection' target='_blank' rel='external'>Collection</a></code> types enable access to one or more specific elements, <code><a href='https://swiftinit.org/docs/swift/swift/sequence' target='_blank' rel='external'>Sequence</a></code> do not necessarily provide this capability. A Sequence solely has the ability to iterate upon a set of elements.</p><p>When you’re using a <code>for .. in</code> loop to iterate elements, you’re always leveraging the sequence APIs.</p><h3 id='IteratorProtocol'><a href='#IteratorProtocol'>IteratorProtocol</a></h3><p>Sequence implementations only need to provide one function, the <code>makeIterator</code> function. This function creates an <code><a href='https://swiftinit.org/docs/swift/swift/iteratorprotocol' target='_blank' rel='external'>IteratorProtocol</a></code> that you implement as well.</p><p><em>IteratorProtocol</em> should be implemented as a <code>struct</code>, and has a single function called <code><a href='https://swiftinit.org/docs/swift/swift/iteratorprotocol.next' target='_blank' rel='external'>next</a></code>. This <em>mutating</em> function returns the next element in the sequence.</p><p>A common way to consume sequences and iterators is the <code>for .. in</code> syntax:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>for</span> <span class='xv'>element</span> <span class='xk'>in</span> <span class='xv'>mySequence</span> {<span class='newline'>
</span>    <a class='xv' href='https://swiftinit.org/docs/swift/swift.print(_:separator:terminator:)' target='_blank' rel='external'>print</a>(<span class='xv'>element</span>)<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/advanced-async-sequences.swift#L4' target='_blank' class='source github'><span class='file'>advanced-async-sequences.swift</span>:<span class='line'>4</span></a><p>Swift uses some syntax sugar in the above example, and unwinds that code behind the scenes:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>var</span> <span class='xv'>iterator</span> = <span class='xv'>mySequence</span>.<a class='xv' href='https://swiftinit.org/docs/swift/swift/collection.makeiterator?hash=85CYW' target='_blank' rel='external'>makeIterator</a>()<span class='newline'>
</span><span class='xk'>while</span> <span class='xk'>let</span> <span class='xv'>element</span> = <span class='xv'>iterator</span>.<a class='xv' href='https://swiftinit.org/docs/swift/swift/indexingiterator.next' target='_blank' rel='external'>next</a>() {<span class='newline'>
</span>    <a class='xv' href='https://swiftinit.org/docs/swift/swift.print(_:separator:terminator:)' target='_blank' rel='external'>print</a>(<span class='xv'>element</span>)<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/advanced-async-sequences.swift#L12' target='_blank' class='source github'><span class='file'>advanced-async-sequences.swift</span>:<span class='line'>12</span></a><p>The <code><a href='https://swiftinit.org/docs/swift/swift/iteratorprotocol.next' target='_blank' rel='external'>next</a></code> function returns the Element as an <code><a href='https://swiftinit.org/docs/swift/swift/optional' target='_blank' rel='external'>Optional</a></code>. The sequence ends when the ‘next’ element is <code>nil</code>.</p><p>While Sequences commonly represent a collection of elements, there’s no hard requirement that a sequence does so. In fact, a sequence doesn’t even need to be <em>finite</em>. You could implement a random number generator that indefinitely outputs new random numbers when iterated upon.</p><h2 id='AsyncSequences'><a href='#AsyncSequences'>AsyncSequences</a></h2><p><code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence' target='_blank' rel='external'>AsyncSequence</a></code>s work very similarly to <code><a href='https://swiftinit.org/docs/swift/swift/sequence' target='_blank' rel='external'>Sequence</a></code>, in that they create an iterator that has a <code>next</code> function. Unlike Sequence, an AsyncSequence uses <code><a href='https://swiftinit.org/docs/swift/_concurrency/asynciteratorprotocol' target='_blank' rel='external'>AsyncIteratorProtocol</a></code>, which is created in <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence' target='_blank' rel='external'>AsyncSequence</a>.<a href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence.makeasynciterator' target='_blank' rel='external'>makeAsyncIterator</a></code>. The iterator returns its <code><a href='https://swiftinit.org/docs/swift/_concurrency/asynciteratorprotocol.next' target='_blank' rel='external'>next</a></code> result asynchronously as well, using structured concurrency.</p><p>This enables the following syntax:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>for</span> <span class='xk'>await</span> <span class='xv'>element</span> <span class='xk'>in</span> <span class='xv'>myAsyncSequence</span> {<span class='newline'>
</span>    <a class='xv' href='https://swiftinit.org/docs/swift/swift.print(_:separator:terminator:)' target='_blank' rel='external'>print</a>(<span class='xv'>element</span>)<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/advanced-async-sequences.swift#L46' target='_blank' class='source github'><span class='file'>advanced-async-sequences.swift</span>:<span class='line'>46</span></a><p>This unwinds to the following code:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>var</span> <span class='xv'>iterator</span> = <span class='xv'>myAsyncSequence</span>.<a class='xv' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream.makeasynciterator' target='_blank' rel='external'>makeAsyncIterator</a>()<span class='newline'>
</span><span class='xk'>while</span> <span class='xk'>let</span> <span class='xv'>element</span> = <span class='xk'>await</span> <span class='xv'>iterator</span>.<a class='xv' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream/iterator.next' target='_blank' rel='external'>next</a>() {<span class='newline'>
</span>    <a class='xv' href='https://swiftinit.org/docs/swift/swift.print(_:separator:terminator:)' target='_blank' rel='external'>print</a>(<span class='xv'>element</span>)<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/advanced-async-sequences.swift#L55' target='_blank' class='source github'><span class='file'>advanced-async-sequences.swift</span>:<span class='line'>55</span></a><p>The simplest AsyncSequence you can create is <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream' target='_blank' rel='external'>AsyncStream</a></code>, which we’ll cover later.</p><h3 id='Throwing%20Async%20Iterators'><a href='#Throwing%20Async%20Iterators'>Throwing Async Iterators</a></h3><p>Unlike IteratorProtocol, an <code><a href='https://swiftinit.org/docs/swift/_concurrency/asynciteratorprotocol' target='_blank' rel='external'>AsyncIteratorProtocol</a></code> has another big trick up its sleeve!</p><p>An AsyncIterator can <code>throw</code> errors from the <code><a href='https://swiftinit.org/docs/swift/_concurrency/asynciteratorprotocol.next' target='_blank' rel='external'>next</a></code> function. In addition to returning <code>nil</code>, a sequence can end when it throws an error. This is extremely helpful for using an AsyncSequence in networking operations - which can encounter errors in addition to being async calls.</p><p>The throwing counterpart to <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream' target='_blank' rel='external'>AsyncStream</a></code> is <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncthrowingstream' target='_blank' rel='external'>AsyncThrowingStream</a></code>, which we’ll also cover later. You can iterate over throwing async sequences in a similar way to non-throwing async sequences:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>for</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>element</span> <span class='xk'>in</span> <span class='xv'>myAsyncThrowingSequence</span> {<span class='newline'>
</span>    <a class='xv' href='https://swiftinit.org/docs/swift/swift.print(_:separator:terminator:)' target='_blank' rel='external'>print</a>(<span class='xv'>element</span>)<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/advanced-async-sequences.swift#L65' target='_blank' class='source github'><span class='file'>advanced-async-sequences.swift</span>:<span class='line'>65</span></a><p>Some libraries such as <a href='https://github.com/orlandos-nl/MongoKitten' target='_blank' rel='external'>MongoKitten</a> use a throwing <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence' target='_blank' rel='external'>AsyncSequence</a></code> to provide a stream of documents from a MongoDB collection. Since network errors can occur at any point, these errors are thrown from the iterator.</p><h2 id='Using%20AsyncStream'><a href='#Using%20AsyncStream'>Using AsyncStream</a></h2><p>The simplest way to create an <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence' target='_blank' rel='external'>AsyncSequence</a></code> is to use <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream' target='_blank' rel='external'>AsyncStream</a></code>. This is a stream of elements that you can append to, and iterate over. The main way to create an <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence' target='_blank' rel='external'>AsyncSequence</a></code> is to use the static <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream.makestream(of:bufferingpolicy:)' target='_blank' rel='external'>makeStream(of:bufferingPolicy:)</a></code> function.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>let</span> (<span class='xv'>stream</span>, <span class='xv'>continuation</span>) = <a class='xt' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream' target='_blank' rel='external'>AsyncStream</a>&lt;<a class='xt' href='https://swiftinit.org/docs/swift/swift/int' target='_blank' rel='external'>Int</a>&gt;.<a class='xv' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream.makestream(of:bufferingpolicy:)' target='_blank' rel='external'>makeStream</a>()</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/advanced-async-sequences.swift#L21' target='_blank' class='source github'><span class='file'>advanced-async-sequences.swift</span>:<span class='line'>21</span></a><p>The two arguments of the function have a default value. <code>of:</code> specifies the type of element that this stream carries. This is currently being inferred to <code><a href='https://swiftinit.org/docs/swift/swift/int' target='_blank' rel='external'>Int</a></code> through generics.</p><p><code>bufferingPolicy:</code> specifies how the stream should buffer elements. The default value is <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream' target='_blank' rel='external'>AsyncStream</a>.<a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream/continuation' target='_blank' rel='external'>Continuation</a>.<a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream/continuation/bufferingpolicy' target='_blank' rel='external'>BufferingPolicy</a>.<a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream/continuation/bufferingpolicy.unbounded' target='_blank' rel='external'>unbounded</a></code>. This means that the stream will buffer all elements until they are consumed. If you want to limit the buffer size, you can use <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream/continuation/bufferingpolicy.bufferingoldest(_:)' target='_blank' rel='external'>bufferingOldest(_:)</a></code> or <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream/continuation/bufferingpolicy.bufferingnewest(_:)' target='_blank' rel='external'>bufferingNewest(_:)</a></code>.</p><p>You can add elements to the stream using the <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream/continuation.yield(_:)' target='_blank' rel='external'>yield(_:)</a></code> function. This mechanism is great for bridging synchronous code with async code. For example, you can use a synchronous function to generate elements, and yield them to the stream.</p><h3 id='Implementing%20AsyncStream'><a href='#Implementing%20AsyncStream'>Implementing AsyncStream</a></h3><p>To create an AsyncStream, first you need to define the type of elements that the stream will carry. In this case, a custom Event is being defined.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xc'>// Define all UI events that a user can send</span><span class='newline'>
</span><span class='xk'>enum</span> <span class='xt'>UIEvent</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/sendable' target='_blank' rel='external'>Sendable</a> {<span class='newline'>
</span>    <span class='xk'>case</span> <span class='xv'>startDownloadTapped</span><span class='newline'>
</span>}<span class='newline'>

</span><span class='xc'>// Create a stream of UI events</span><span class='newline'>
</span><span class='xk'>let</span> (<span class='xv'>stream</span>, <span class='xv'>continuation</span>) = <a class='xt' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream' target='_blank' rel='external'>AsyncStream</a>&lt;<span class='xt'>UIEvent</span>&gt;.<a class='xv' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream.makestream(of:bufferingpolicy:)' target='_blank' rel='external'>makeStream</a>()</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/advanced-async-sequences.swift#L72' target='_blank' class='source github'><span class='file'>advanced-async-sequences.swift</span>:<span class='line'>72</span></a><p>After creating the stream, you can yield events to the stream. This is done by calling the <code>yield</code> function on the continuation. The follwing example shows how to yield an event when a button is tapped in SwiftUI. Note that these practices can be used in any Swift codebase, including on Linux and Windows.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>struct</span> <span class='xv'>StartDownloadView</span>: <span class='xt'>View</span> {<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>continuation</span>: <span class='xt'>AsyncStream</span>&lt;<span class='xt'>UIEvent</span>&gt;.<span class='xt'>Continuation</span><span class='newline'>

</span>    <span class='xk'>var</span> <span class='xv'>body</span>: <span class='xk'>some</span> <span class='xt'>View</span> {<span class='newline'>
</span>        <span class='xv'>Button</span>(<span class='xs'>"Start Download"</span>) {<span class='newline'>
</span>            <span class='xv'>continuation</span>.<span class='xv'>yield</span>(.<span class='xv'>startDownloadTapped</span>)<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>By leveraging the structured nature of Swift’s concurrency model, we can predict the behavior of our code more easily. For example, when a user taps the button twice, we can be sure that the stream will receive two events in order.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>actor</span> <span class='xt'>AppState</span> {<span class='newline'>
</span>    <span class='xk'>enum</span> <span class='xt'>DownloadState</span> {<span class='newline'>
</span>        <span class='xk'>case</span> <span class='xv'>notDownloaded</span><span class='newline'>
</span>        <span class='xk'>case</span> <span class='xv'>downloading</span><span class='newline'>
</span>        <span class='xk'>case</span> <span class='xv'>downloaded</span><span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>var</span> <span class='xv'>downloadState</span> = <span class='xt'>DownloadState</span>.<span class='xv'>notDownloaded</span><span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>stream</span>: <a class='xt' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream' target='_blank' rel='external'>AsyncStream</a>&lt;<span class='xt'>UIEvent</span>&gt;<span class='newline'>

</span>    <span class='xk'>init</span>(<span class='xv'>stream</span>: <a class='xt' href='https://swiftinit.org/docs/swift/_concurrency/asyncstream' target='_blank' rel='external'>AsyncStream</a>&lt;<span class='xt'>UIEvent</span>&gt;) {<span class='newline'>
</span>        <span class='xk'>self</span>.<span class='xv'>stream</span> = <span class='xv'>stream</span><span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>handleEvents</span>() <span class='xk'>async</span> {<span class='newline'>
</span>        <span class='xk'>for</span> <span class='xk'>await</span> <span class='xv'>event</span> <span class='xk'>in</span> <span class='xv'>stream</span> {<span class='newline'>
</span>            <span class='xk'>switch</span> <span class='xv'>event</span> {<span class='newline'>
</span>            <span class='xk'>case</span> .<span class='xv'>startDownloadTapped</span>:<span class='newline'>
</span>                <span class='xk'>switch</span> <span class='xv'>downloadState</span> {<span class='newline'>
</span>                <span class='xk'>case</span> .<span class='xv'>notDownloaded</span>:<span class='newline'>
</span>                    <span class='xv'>downloadState</span> = .<span class='xv'>downloading</span><span class='newline'>
</span>                    <span class='xk'>do</span> {<span class='newline'>
</span>                        <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>startDownload</span>()<span class='newline'>
</span>                        <span class='xv'>downloadState</span> = .<span class='xv'>downloaded</span><span class='newline'>
</span>                    }<span class='newline'>
</span>                    <span class='xk'>catch</span> {<span class='newline'>
</span>                        <span class='xv'>downloadState</span> = .<span class='xv'>notDownloaded</span><span class='newline'>
</span>                    }<span class='newline'>
</span>                <span class='xk'>case</span> .<span class='xv'>downloading</span>, .<span class='xv'>downloaded</span>:<span class='newline'>
</span>                    <span class='xc'>// Don't respond to user input</span><span class='newline'>
</span>                    <span class='xk'>continue</span><span class='newline'>
</span>                }<span class='newline'>
</span>            }<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/advanced-async-sequences.swift#L84' target='_blank' class='source github'><span class='file'>advanced-async-sequences.swift</span>:<span class='line'>84</span></a><h3 id='Parallising%20Work'><a href='#Parallising%20Work'>Parallising Work</a></h3><p>The main issue in the above logic is that the <code>startDownload</code> function is prevening the app from handling other UIEvents while the download is still in progress. Due to structured concurrency, your UI won’t freeze, but any events are still being queued up and not executing. This can be a problem if you have multiple actions that do not interact with each other.</p><p>We can rewrite the loop using a <code><a href='https://swiftinit.org/docs/swift/_concurrency/discardingtaskgroup' target='_blank' rel='external'>DiscardingTaskGroup</a></code> to start the download in parallel with handling other events.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>func</span> <span class='xv'>setDownloadState</span>(_ <span class='xv'>state</span>: <span class='xt'>AppState</span>.<span class='xt'>DownloadState</span>) {<span class='newline'>
</span>    <span class='xv'>downloadState</span> = <span class='xv'>state</span><span class='newline'>
</span>}<span class='newline'>

</span><span class='xk'>func</span> <span class='xv'>handleEvents</span>() <span class='xk'>async</span> {<span class='newline'>
</span>    <span class='xk'>await</span> <a class='xv' href='https://swiftinit.org/docs/swift/_concurrency.withdiscardingtaskgroup(returning:body:)' target='_blank' rel='external'>withDiscardingTaskGroup</a> { <span class='xv'>taskGroup</span> <span class='xk'>in</span><span class='newline'>
</span>        <span class='xk'>for</span> <span class='xk'>await</span> <span class='xv'>event</span> <span class='xk'>in</span> <span class='xv'>stream</span> {<span class='newline'>
</span>            <span class='xk'>switch</span> <span class='xv'>event</span> {<span class='newline'>
</span>            <span class='xk'>case</span> .<span class='xv'>startDownloadTapped</span>:<span class='newline'>
</span>                <span class='xk'>switch</span> <span class='xv'>downloadState</span> {<span class='newline'>
</span>                <span class='xk'>case</span> .<span class='xv'>notDownloaded</span>:<span class='newline'>
</span>                    <span class='xv'>downloadState</span> = .<span class='xv'>downloading</span><span class='newline'>
</span>                    <span class='xv'>taskGroup</span>.<a class='xv' href='https://swiftinit.org/docs/swift/_concurrency/discardingtaskgroup.addtask(operation:)' target='_blank' rel='external'>addTask</a> {<span class='newline'>
</span>                        <span class='xc'>// This code runs in parallel with the loop</span><span class='newline'>
</span>                        <span class='xc'>// It doesn't block the loop from handling other events</span><span class='newline'>
</span>                        <span class='xk'>do</span> {<span class='newline'>
</span>                            <span class='xk'>try</span> <span class='xk'>await</span> <span class='xk'>self</span>.<span class='xv'>startDownload</span>()<span class='newline'>
</span>                            <span class='xk'>await</span> <span class='xk'>self</span>.<span class='xv'>setDownloadState</span>(.<span class='xv'>downloaded</span>)<span class='newline'>
</span>                        }<span class='newline'>
</span>                        <span class='xk'>catch</span> {<span class='newline'>
</span>                            <span class='xk'>await</span> <span class='xk'>self</span>.<span class='xv'>setDownloadState</span>(.<span class='xv'>notDownloaded</span>)<span class='newline'>
</span>                        }<span class='newline'>
</span>                    }<span class='newline'>
</span>                <span class='xk'>case</span> .<span class='xv'>downloading</span>, .<span class='xv'>downloaded</span>:<span class='newline'>
</span>                    <span class='xc'>// Don't respond to user input</span><span class='newline'>
</span>                    <span class='xk'>continue</span><span class='newline'>
</span>                }<span class='newline'>
</span>            }<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/advanced-async-sequences.swift#L137' target='_blank' class='source github'><span class='file'>advanced-async-sequences.swift</span>:<span class='line'>137</span></a><p>The <code>downloadState</code> property is set to <code>downloading</code> before parallelising work. This ensures that quickly tapping the button twice can never result in two downloads happening at the same time.</p><h2 id='Implementing%20Custom%20AsyncSequence'><a href='#Implementing%20Custom%20AsyncSequence'>Implementing Custom AsyncSequence</a></h2><p>You can implement your own <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence' target='_blank' rel='external'>AsyncSequence</a></code> by implementing the <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence' target='_blank' rel='external'>AsyncSequence</a></code> protocol. This protocol has two associated types: <code>Element</code> and <code>AsyncIterator</code>. You’ll need to implement the <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence.makeasynciterator' target='_blank' rel='external'>makeAsyncIterator</a></code> function and the <code><a href='https://swiftinit.org/docs/swift/_concurrency/asynciteratorprotocol' target='_blank' rel='external'>AsyncIteratorProtocol</a></code>.</p><p>First we’ll define our custom <code>DelayedElementEmitter</code> struct. This struct will emit elements from an array with a delay between each element.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>struct</span> <span class='xt'>DelayedElementEmitter</span>&lt;<span class='xt'>Element</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/sendable' target='_blank' rel='external'>Sendable</a>&gt;: <a class='xt' href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence' target='_blank' rel='external'>AsyncSequence</a> {<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>elements</span>: [<span class='xt'>Element</span>]<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>delay</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/duration' target='_blank' rel='external'>Duration</a><span class='newline'>

</span>    <span class='xk'>init</span>(<span class='xv'>elements</span>: [<span class='xt'>Element</span>], <span class='xv'>delay</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/duration' target='_blank' rel='external'>Duration</a>) {<span class='newline'>
</span>        <span class='xk'>self</span>.<span class='xv'>elements</span> = <span class='xv'>elements</span><span class='newline'>
</span>        <span class='xk'>self</span>.<span class='xv'>delay</span> = <span class='xv'>delay</span><span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/advanced-async-sequences.swift#L176' target='_blank' class='source github'><span class='file'>advanced-async-sequences.swift</span>:<span class='line'>176</span></a><p>This struct needs an iterator and a function to construct that iterator. The iterator is not expected to be shared between multiple consumers, so it can be a struct.</p><p>Unlike a regular <code><a href='https://swiftinit.org/docs/swift/swift/sequence' target='_blank' rel='external'>Sequence</a></code>, the <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence.makeasynciterator' target='_blank' rel='external'>makeAsyncIterator</a></code> is expected to be called only once. While structured concurrency allows calling this function multiple times, it’s not expected that a sequence supports this in practice.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>extension</span> <span class='xt'>DelayedElementEmitter</span> {<span class='newline'>
</span>    <span class='xk'>struct</span> <span class='xt'>AsyncIterator</span>: <a class='xt' href='https://swiftinit.org/docs/swift/_concurrency/asynciteratorprotocol' target='_blank' rel='external'>AsyncIteratorProtocol</a> {<span class='newline'>
</span>        <span class='xk'>var</span> <span class='xv'>elements</span>: [<span class='xt'>Element</span>]<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>delay</span>: <a class='xt' href='https://swiftinit.org/docs/swift/swift/duration' target='_blank' rel='external'>Duration</a><span class='newline'>

</span>        <span class='xk'>mutating</span> <span class='xk'>func</span> <span class='xv'>next</span>() <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>Element</span>? {<span class='newline'>
</span>            <span class='xk'>try</span> <span class='xk'>await</span> <a class='xt' href='https://swiftinit.org/docs/swift/_concurrency/task' target='_blank' rel='external'>Task</a>.<a class='xv' href='https://swiftinit.org/docs/swift/_concurrency/task.sleep(for:tolerance:clock:)' target='_blank' rel='external'>sleep</a>(<span class='xv'>for</span>: <span class='xv'>delay</span>)<span class='newline'>
</span>            <span class='xk'>guard</span> <span class='xv'>elements</span>.<a class='xv' href='https://swiftinit.org/docs/swift/swift/collection.isempty?hash=17ZOY' target='_blank' rel='external'>isEmpty</a> <span class='xk'>else</span> {<span class='newline'>
</span>                <span class='xk'>return</span> <span class='xv'>elements</span>.<a class='xv' href='https://swiftinit.org/docs/swift/swift/rangereplaceablecollection.removefirst?hash=9KZAY' target='_blank' rel='external'>removeFirst</a>()<span class='newline'>
</span>            }<span class='newline'>
</span>            <span class='xk'>return</span> <span class='xk'>nil</span><span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>makeAsyncIterator</span>() -&gt; <span class='xt'>AsyncIterator</span> {<span class='newline'>
</span>        <span class='xt'>AsyncIterator</span>(<span class='newline'>
</span>            <span class='xv'>elements</span>: <span class='xv'>elements</span>,<span class='newline'>
</span>            <span class='xv'>delay</span>: <span class='xv'>delay</span><span class='newline'>
</span>        )<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><a rel='ugc' href='https://github.com/swift-on-server/articles/blob/main/Snippets/advanced-async-sequences.swift#L187' target='_blank' class='source github'><span class='file'>advanced-async-sequences.swift</span>:<span class='line'>187</span></a><p>You can now use this custom <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncsequence' target='_blank' rel='external'>AsyncSequence</a></code> in your code. The following example shows how to create a sequence that emits numbers from 1 to 5 with a delay of 1 second between each number.</p><p>Note that our custom <code>DelayedElementEmitter</code> cannot be iterated upon without a <code>try</code> keyword to handle errors. This is because the <code><a href='https://swiftinit.org/docs/swift/_concurrency/asynciteratorprotocol.next' target='_blank' rel='external'>next</a></code> function can throw errors due to being marked as <code>throws</code>. We can also handle the <code><a href='https://swiftinit.org/docs/swift/_concurrency/cancellationerror' target='_blank' rel='external'>CancellationError</a></code>s that <code><a href='https://swiftinit.org/docs/swift/_concurrency/task' target='_blank' rel='external'>Task</a>.<a href='https://swiftinit.org/docs/swift/_concurrency/task.sleep(for:tolerance:clock:)' target='_blank' rel='external'>sleep(for:tolerance:clock:)</a></code> throws in the <code>next()</code> function.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>mutating</span> <span class='xk'>func</span> <span class='xv'>next</span>() <span class='xk'>async</span> -&gt; <span class='xt'>Element</span>? {<span class='newline'>
</span>    <span class='xk'>do</span> {<span class='newline'>
</span>        <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>Task</span>.<span class='xv'>sleep</span>(<span class='xv'>for</span>: <span class='xv'>delay</span>)<span class='newline'>
</span>    } <span class='xk'>catch</span> {<span class='newline'>
</span>        <span class='xk'>return</span> <span class='xk'>nil</span><span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>if</span> <span class='xv'>elements</span>.<span class='xv'>isEmpty</span> {<span class='newline'>
</span>        <span class='xk'>return</span> <span class='xk'>nil</span><span class='newline'>
</span>    } <span class='xk'>else</span> {<span class='newline'>
</span>        <span class='xk'>return</span> <span class='xv'>elements</span>.<span class='xv'>removeFirst</span>()<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>The above change would allow you to iterate over the sequence without needing to handle errors.</p><h3 id='Cancellation'><a href='#Cancellation'>Cancellation</a></h3><p>The <code><a href='https://swiftinit.org/docs/swift/_concurrency/asynciteratorprotocol.next' target='_blank' rel='external'>next</a></code> function can be cancelled by the consumer. This can be done through <code><a href='https://swiftinit.org/docs/swift/_concurrency/taskgroup' target='_blank' rel='external'>TaskGroup</a>.<a href='https://swiftinit.org/docs/swift/_concurrency/taskgroup.cancelall' target='_blank' rel='external'>cancelAll</a></code>, <code><a href='https://swiftinit.org/docs/swift/_concurrency/task' target='_blank' rel='external'>Task</a>.<a href='https://swiftinit.org/docs/swift/_concurrency/task.cancel' target='_blank' rel='external'>cancel</a></code> or a variety of other cancellation mechanisms.</p><p>It is expected that Async Sequences handle cancellation gracefully as appropriate. In Networking, this could mean cancelling a network request. In a generator, this could mean stopping the generation of new elements through <code><a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream' target='_blank' rel='external'>AsyncStream</a>.<a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream/continuation' target='_blank' rel='external'>Continuation</a>.<a href='https://swiftinit.org/docs/swift/_concurrency/asyncstream/continuation.finish' target='_blank' rel='external'>finish</a></code>.</p><p>To detect a cancellation signal, use <code><a href='https://swiftinit.org/docs/swift/_concurrency.withtaskcancellationhandler(operation:oncancel:)' target='_blank' rel='external'>withTaskCancellationHandler(operation:onCancel:)</a></code>. Or when using Swift Service Lifecycle, use <code><a href='https://swiftinit.org/docs/swift-service-lifecycle/servicelifecycle.withtaskcancellationorgracefulshutdownhandler(operation:oncancelorgracefulshutdown:)' target='_blank' rel='external'>withTaskCancellationOrGracefulShutdownHandler(operation:onCancelOrGracefulShutdown:)</a></code>.</p><h2 id='Changes%20in%20Swift%206'><a href='#Changes%20in%20Swift%206'>Changes in Swift 6</a></h2><p>In Swift 5, any <code>async</code> function that does not use actor isolation implicitly runs on the global concurrent executor. This means that the <code><a href='https://swiftinit.org/docs/swift/_concurrency/asynciteratorprotocol' target='_blank' rel='external'>AsyncIteratorProtocol</a>.<a href='https://swiftinit.org/docs/swift/_concurrency/asynciteratorprotocol.next' target='_blank' rel='external'>next</a></code> function runs on the global concurrent executor as well.</p><p>Starting with Swift 6, a variant of this function is available.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>mutating</span> <span class='xk'>func</span> <span class='xv'>next</span>(<span class='xv'>isolation</span> <span class='xv'>actor</span>: <span class='xk'>isolated</span> (<span class='xk'>any</span> <span class='xt'>Actor</span>)? = #<span class='xv'>isolation</span>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>Element</span>?</code></pre><p>The <code>isolated (any Actor)?</code> argument allows callees to tell an <code>async</code> function which actor the function runs on. This is helpful for performance-sensitive contexts.</p><p>Finally, Swift 6’ AsyncSequences can specify an <code>associatedtype Failure: Error</code>. Using typed throws, you can specify the type of error that the iterator can throw.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>mutating</span> <span class='xk'>func</span> <span class='xv'>next</span>(<span class='xv'>isolation</span> <span class='xv'>actor</span>: <span class='xk'>isolated</span> (<span class='xk'>any</span> <span class='xt'>Actor</span>)? = #<span class='xv'>isolation</span>) <span class='xk'>async</span> <span class='xk'>throws</span>(<span class='xv'>Failure</span>) -&gt; <span class='xv'>Element</span>?</code></pre><p>By default, <code>throws</code> is equivalent to <code>throws(any Error)</code>, and this is reflected when you omit specifying a specific <code><a href='https://swiftinit.org/docs/swift/swift/error' target='_blank' rel='external'>Error</a></code> type in Failure.</p><h2 id='Conclusion'><a href='#Conclusion'>Conclusion</a></h2><p>AsyncSequences are a cornerstone of structured concurrency in Swift. They enable you to create streams of elements that can be iterated upon asynchronously. They’re especially useful in networking, but also serve great purpose in UI programming and other areas.</p></section><div style='display: none;' id='ss:tooltips'><a href='/docs/swift/_concurrency/asyncsequence'><pre><code><span class='xa'>@rethrows</span> <span class='xk'>protocol</span> <span class='xv'>AsyncSequence</span></code></pre><p>A type that provides asynchronous, sequential, iterated access to its elements.</p></a><a href='/hist/swift-on-server.articles:main/articles/getting-started-with-structured-concurrency-in-swift'><p>Swift 5.5 introduced structured concurrency. The new way to write concurrent code that is more maintainable and easier to reason about. A lot of developers have been adopting concurrency in Swift. But few people understand what ‘<strong>structured</strong>’ means in this context, and how it helps you.</p></a><a href='/hist/swift-on-server.articles:main/articles/structured-concurrency-and-shared-state-in-swift'><p>When working with concurrent code, you’ll often need to share state between tasks. Using reference types such as a <code>class</code> allows you to share state between different threads and tasks. This can lead to race conditions where two tasks are trying to access the same state at the same time.</p></a><a href='/docs/swift/swift/sequence'><pre><code><span class='xk'>protocol</span> <span class='xv'>Sequence</span>&lt;<span class='xv'>Element</span>&gt;</code></pre><p>A type that provides sequential, iterated access to its elements.</p></a><a href='/docs/swift/swift/array'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>Array</span>&lt;<span class='xu'>Element</span>&gt;</code></pre><p>An ordered, random-access collection.</p></a><a href='/docs/swift/swift/set'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>Set</span>&lt;<span class='xu'>Element</span>&gt; <span class='xk'>where</span> <span class='xt'>Element</span> : <span class='xt'>Hashable</span></code></pre><p>An unordered collection of unique elements.</p></a><a href='/docs/swift/swift/dictionary'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>Dictionary</span>&lt;<span class='xu'>Key</span>, <span class='xu'>Value</span>&gt; <span class='xk'>where</span> <span class='xt'>Key</span> : <span class='xt'>Hashable</span></code></pre><p>A collection whose elements are key-value pairs.</p></a><a href='/docs/swift/swift/collection'><pre><code><span class='xk'>protocol</span> <span class='xv'>Collection</span>&lt;<span class='xv'>Element</span>&gt; : <span class='xt'>Sequence</span></code></pre><p>A sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.</p></a><a href='/docs/swift/swift/int'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>Int</span></code></pre><p>A signed integer value type.</p></a><a href='/docs/swift/swift/iteratorprotocol'><pre><code><span class='xk'>protocol</span> <span class='xv'>IteratorProtocol</span>&lt;<span class='xv'>Element</span>&gt;</code></pre><p>A type that supplies the values of a sequence one at a time.</p></a><a href='/docs/swift/swift/iteratorprotocol.next'><pre><code><span class='xk'>mutating</span> <span class='xk'>func</span> <span class='xv'>next</span>(<wbr>) -&gt; <span class='xk'>Self</span>.<span class='xt'>Element</span>?</code></pre><p>Advances to the next element and returns it, or <code>nil</code> if no next element exists.</p></a><a href='/docs/swift/swift.print(_:separator:terminator:)'><pre><code><span class='xk'>func</span> <span class='xv'>print</span>(<span class='xi'></span>_ <span class='xb'>items</span>: <span class='xk'>Any</span>..., <span class='xi'></span><span class='xv'>separator</span>: <span class='xt'>String</span> = <span class='xs'>" "</span>, <span class='xi'></span><span class='xv'>terminator</span>: <span class='xt'>String</span> = <span class='xs'>"\n"</span><wbr>)</code></pre><p>Writes the textual representations of the given items into the standard output.</p></a><a href='/docs/swift/swift/collection.makeiterator?hash=85CYW'><pre><code><span class='xk'>func</span> <span class='xv'>makeIterator</span>(<wbr>) -&gt; <span class='xt'>IndexingIterator</span>&lt;<span class='xk'>Self</span>&gt;</code></pre><p>Returns an iterator over the elements of the collection.</p></a><a href='/docs/swift/swift/indexingiterator.next'><pre><code><span class='xk'>mutating</span> <span class='xk'>func</span> <span class='xv'>next</span>(<wbr>) -&gt; <span class='xt'>Elements</span>.<span class='xt'>Element</span>?</code></pre><p>Advances to the next element and returns it, or <code>nil</code> if no next element exists.</p></a><a href='/docs/swift/swift/optional'><pre><code><span class='xa'>@frozen</span> <span class='xk'>enum</span> <span class='xv'>Optional</span>&lt;<span class='xu'>Wrapped</span>&gt;</code></pre><p>A type that represents either a wrapped value or the absence of a value.</p></a><a href='/docs/swift/_concurrency/asynciteratorprotocol'><pre><code><span class='xa'>@rethrows</span> <span class='xk'>protocol</span> <span class='xv'>AsyncIteratorProtocol</span></code></pre><p>A type that asynchronously supplies the values of a sequence one at a time.</p></a><a href='/docs/swift/_concurrency/asyncsequence.makeasynciterator'><pre><code><span class='xk'>func</span> <span class='xv'>makeAsyncIterator</span>(<wbr>) -&gt; <span class='xk'>Self</span>.<span class='xt'>AsyncIterator</span></code></pre><p>Creates the asynchronous iterator that produces elements of this asynchronous sequence.</p></a><a href='/docs/swift/_concurrency/asynciteratorprotocol.next'><pre><code><span class='xk'>mutating</span> <span class='xk'>func</span> <span class='xv'>next</span>(<wbr>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xk'>Self</span>.<span class='xt'>Element</span>?</code></pre><p>Asynchronously advances to the next element and returns it, or ends the sequence if there is no next element.</p></a><a href='/docs/swift/_concurrency/asyncstream.makeasynciterator'><pre><code><span class='xk'>func</span> <span class='xv'>makeAsyncIterator</span>(<wbr>) -&gt; <span class='xt'>AsyncStream</span>&lt;<span class='xt'>Element</span>&gt;.<span class='xt'>Iterator</span></code></pre><p>Creates the asynchronous iterator that produces elements of this asynchronous sequence.</p></a><a href='/docs/swift/_concurrency/asyncstream/iterator.next'><pre><code><span class='xk'>mutating</span> <span class='xk'>func</span> <span class='xv'>next</span>(<wbr>) <span class='xk'>async</span> -&gt; <span class='xt'>Element</span>?</code></pre><p>The next value from the asynchronous stream.</p></a><a href='/docs/swift/_concurrency/asyncstream'><pre><code><span class='xk'>struct</span> <span class='xv'>AsyncStream</span>&lt;<span class='xu'>Element</span>&gt;</code></pre><p>An asynchronous sequence generated from a closure that calls a continuation to produce new elements.</p></a><a href='/docs/swift/_concurrency/asyncthrowingstream'><pre><code><span class='xk'>struct</span> <span class='xv'>AsyncThrowingStream</span>&lt;<span class='xu'>Element</span>, <span class='xu'>Failure</span>&gt; <span class='xk'>where</span> <span class='xt'>Failure</span> : <span class='xt'>Error</span></code></pre><p>An asynchronous sequence generated from an error-throwing closure that calls a continuation to produce new elements.</p></a><a href='/docs/swift/_concurrency/asyncstream.makestream(of:bufferingpolicy:)'><pre><code><span class='xa'>@backDeployed</span>(<span class='xk'>before</span>: <span class='xk'>macOS</span> <span class='xn'>14</span>.<span class='xn'>0</span>, <span class='xk'>iOS</span> <span class='xn'>17</span>.<span class='xn'>0</span>, <span class='xk'>watchOS</span> <span class='xn'>10</span>.<span class='xn'>0</span>, <span class='xk'>tvOS</span> <span class='xn'>17</span>.<span class='xn'>0</span>)
<span class='xk'>static</span> <span class='xk'>func</span> <span class='xv'>makeStream</span>(<span class='xi'></span><span class='xv'>of</span> <span class='xb'>elementType</span>: <span class='xt'>Element</span>.<span class='xk'>Type</span> = <span class='xv'>Element</span>.<span class='xk'>self</span>, <span class='xi'></span><span class='xv'>bufferingPolicy</span> <span class='xb'>limit</span>: <span class='xt'>AsyncStream</span>&lt;<span class='xt'>Element</span>&gt;.<span class='xt'>Continuation</span>.<span class='xt'>BufferingPolicy</span> = .<span class='xv'>unbounded</span><wbr>) -&gt; (<span class='xv'>stream</span>: <span class='xt'>AsyncStream</span>&lt;<span class='xt'>Element</span>&gt;, <span class='xv'>continuation</span>: <span class='xt'>AsyncStream</span>&lt;<span class='xt'>Element</span>&gt;.<span class='xt'>Continuation</span>)</code></pre><p>Initializes a new <code>AsyncStream</code> and an <code>Continuation</code>.</p></a><a href='/docs/swift/_concurrency/asyncstream/continuation/bufferingpolicy.unbounded'><pre><code><span class='xk'>case</span> <span class='xv'>unbounded</span></code></pre><p>Continue to add to the buffer, without imposing a limit on the number of buffered elements.</p></a><a href='/docs/swift/_concurrency/asyncstream/continuation'><pre><code><span class='xk'>struct</span> <span class='xv'>Continuation</span></code></pre><p>A mechanism to interface between synchronous code and an asynchronous stream.</p></a><a href='/docs/swift/_concurrency/asyncstream/continuation/bufferingpolicy'><pre><code><span class='xk'>enum</span> <span class='xv'>BufferingPolicy</span></code></pre><p>A strategy that handles exhaustion of a buffer’s capacity.</p></a><a href='/docs/swift/_concurrency/asyncstream/continuation/bufferingpolicy.bufferingoldest(_:)'><pre><code><span class='xk'>case</span> <span class='xv'>bufferingOldest</span>(<span class='xt'>Int</span>)</code></pre><p>When the buffer is full, discard the newly received element.</p></a><a href='/docs/swift/_concurrency/asyncstream/continuation/bufferingpolicy.bufferingnewest(_:)'><pre><code><span class='xk'>case</span> <span class='xv'>bufferingNewest</span>(<span class='xt'>Int</span>)</code></pre><p>When the buffer is full, discard the oldest element in the buffer.</p></a><a href='/docs/swift/_concurrency/asyncstream/continuation.yield(_:)'><pre><code><span class='xa'>@discardableResult</span> <span class='xk'>func</span> <span class='xv'>yield</span>(<span class='xi'></span>_ <span class='xb'>value</span>: <span class='xt'>Element</span><wbr>) -&gt; <span class='xt'>AsyncStream</span>&lt;<span class='xt'>Element</span>&gt;.<span class='xt'>Continuation</span>.<span class='xt'>YieldResult</span></code></pre><p>Resume the task awaiting the next iteration point by having it return normally from its suspension point with a given element.</p></a><a href='/docs/swift/swift/sendable'><pre><code><span class='xk'>protocol</span> <span class='xv'>Sendable</span></code></pre><p>A type whose values can safely be passed across concurrency domains by copying.</p></a><a href='/docs/swift/_concurrency/discardingtaskgroup'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>DiscardingTaskGroup</span></code></pre><p>A discarding group that contains dynamically created child tasks.</p></a><a href='/docs/swift/_concurrency.withdiscardingtaskgroup(returning:body:)'><pre><code><span class='xk'>func</span> <span class='xv'>withDiscardingTaskGroup</span>&lt;<span class='xu'>GroupResult</span>&gt;(<span class='xi'></span><span class='xv'>returning</span> <span class='xb'>returnType</span>: <span class='xt'>GroupResult</span>.<span class='xk'>Type</span> = <span class='xv'>GroupResult</span>.<span class='xk'>self</span>, <span class='xi'></span><span class='xv'>body</span>: (<span class='xk'>inout</span> <span class='xt'>DiscardingTaskGroup</span>) <span class='xk'>async</span> -&gt; <span class='xt'>GroupResult</span><wbr>) <span class='xk'>async</span> -&gt; <span class='xt'>GroupResult</span></code></pre><p>Starts a new scope that can contain a dynamic number of child tasks.</p></a><a href='/docs/swift/_concurrency/discardingtaskgroup.addtask(operation:)'><pre><code><span class='xk'>mutating</span> <span class='xk'>func</span> <span class='xv'>addTask</span>(<span class='xi'></span><span class='xv'>operation</span>: <span class='xa'>@escaping</span> () <span class='xk'>async</span> -&gt; <span class='xt'>Void</span><wbr>)</code></pre></a><a href='/docs/swift/swift/duration'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>Duration</span></code></pre><p>A representation of high precision time.</p></a><a href='/docs/swift/_concurrency/task'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>Task</span>&lt;<span class='xu'>Success</span>, <span class='xu'>Failure</span>&gt; <span class='xk'>where</span> <span class='xt'>Success</span> : <span class='xt'>Sendable</span>, <span class='xt'>Failure</span> : <span class='xt'>Error</span></code></pre><p>A unit of asynchronous work.</p></a><a href='/docs/swift/_concurrency/task.sleep(for:tolerance:clock:)'><pre><code><span class='xk'>static</span> <span class='xk'>func</span> <span class='xv'>sleep</span>&lt;<span class='xu'>C</span>&gt;(<span class='xi'></span><span class='xv'>for</span> <span class='xb'>duration</span>: <span class='xt'>C</span>.<span class='xt'>Instant</span>.<span class='xt'>Duration</span>, <span class='xi'></span><span class='xv'>tolerance</span>: <span class='xt'>C</span>.<span class='xt'>Instant</span>.<span class='xt'>Duration</span>? = <span class='xk'>nil</span>, <span class='xi'></span><span class='xv'>clock</span>: <span class='xt'>C</span> = <span class='xv'>ContinuousClock</span>()<wbr>) <span class='xk'>async</span> <span class='xk'>throws</span> <span class='xk'>where</span> <span class='xt'>C</span> : <span class='xt'>Clock</span></code></pre><p>Suspends the current task for the given duration.</p></a><a href='/docs/swift/swift/collection.isempty?hash=17ZOY'><pre><code><span class='xk'>var</span> <span class='xv'>isEmpty</span>: <span class='xt'>Bool</span> { <span class='xk'>get</span> }</code></pre><p>A Boolean value indicating whether the collection is empty.</p></a><a href='/docs/swift/swift/rangereplaceablecollection.removefirst?hash=9KZAY'><pre><code><span class='xa'>@discardableResult</span> <span class='xk'>mutating</span> <span class='xk'>func</span> <span class='xv'>removeFirst</span>(<wbr>) -&gt; <span class='xk'>Self</span>.<span class='xt'>Element</span></code></pre><p>Removes and returns the first element of the collection.</p></a><a href='/docs/swift/_concurrency/cancellationerror'><pre><code><span class='xk'>struct</span> <span class='xv'>CancellationError</span></code></pre><p>An error that indicates a task was canceled.</p></a><a href='/docs/swift/_concurrency/taskgroup.cancelall'><pre><code><span class='xk'>func</span> <span class='xv'>cancelAll</span>(<wbr>)</code></pre><p>Cancel all of the remaining tasks in the group.</p></a><a href='/docs/swift/_concurrency/taskgroup'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>TaskGroup</span>&lt;<span class='xu'>ChildTaskResult</span>&gt; <span class='xk'>where</span> <span class='xt'>ChildTaskResult</span> : <span class='xt'>Sendable</span></code></pre><p>A group that contains dynamically created child tasks.</p></a><a href='/docs/swift/_concurrency/task.cancel'><pre><code><span class='xk'>func</span> <span class='xv'>cancel</span>(<wbr>)</code></pre><p>Indicates that the task should stop running.</p></a><a href='/docs/swift/_concurrency/asyncstream/continuation.finish'><pre><code><span class='xk'>func</span> <span class='xv'>finish</span>(<wbr>)</code></pre><p>Resume the task awaiting the next iteration point by having it return nil, which signifies the end of the iteration.</p></a><a href='/docs/swift/_concurrency.withtaskcancellationhandler(operation:oncancel:)'><pre><code><span class='xa'>@backDeployed</span>(<span class='xk'>before</span>: <span class='xk'>macOS</span> <span class='xn'>13</span>.<span class='xn'>3</span>, <span class='xk'>iOS</span> <span class='xn'>16</span>.<span class='xn'>4</span>, <span class='xk'>watchOS</span> <span class='xn'>9</span>.<span class='xn'>4</span>, <span class='xk'>tvOS</span> <span class='xn'>16</span>.<span class='xn'>4</span>)
<span class='xk'>func</span> <span class='xv'>withTaskCancellationHandler</span>&lt;<span class='xu'>T</span>&gt;(<span class='xi'></span><span class='xv'>operation</span>: () <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>T</span>, <span class='xi'></span><span class='xv'>onCancel</span> <span class='xb'>handler</span>: () -&gt; <span class='xt'>Void</span><wbr>) <span class='xk'>async</span> <span class='xk'>rethrows</span> -&gt; <span class='xt'>T</span></code></pre><p>Execute an operation with a cancellation handler that’s immediately invoked if the current task is canceled.</p></a><a href='/docs/swift-service-lifecycle/servicelifecycle.withtaskcancellationorgracefulshutdownhandler(operation:oncancelorgracefulshutdown:)'><pre><code><span class='xk'>func</span> <span class='xv'>withTaskCancellationOrGracefulShutdownHandler</span>&lt;<span class='xu'>T</span>&gt;(<span class='xi'></span><span class='xv'>operation</span>: () <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>T</span>, <span class='xi'></span><span class='xv'>onCancelOrGracefulShutdown</span> <span class='xb'>handler</span>: <span class='xa'>@escaping</span> () -&gt; <span class='xt'>Void</span><wbr>) <span class='xk'>async</span> <span class='xk'>rethrows</span> -&gt; <span class='xt'>T</span></code></pre><p>Execute an operation with a graceful shutdown or task cancellation handler that’s immediately invoked if the current task is shutting down gracefully or has been cancelled.</p></a><a href='/docs/swift/swift/error'><pre><code><span class='xk'>protocol</span> <span class='xv'>Error</span> : <span class='xt'>Sendable</span></code></pre><p>A type representing an error value that can be thrown.</p></a></div>
                    
                </section>
    
                <footer>
                    <br>
                    <time datetime=""></time>
    
                    
                    <div class="author-list">
                        <a href="https://swiftonserver.com/authors/joannis-orlandos/">
                        <img class="small rounded" src="/assets/authors/joannis-orlandos/joannis-orlandos.jpeg" alt="Joannis Orlandos">
                        <span class="name">Joannis Orlandos</span>
                        </a>
                    </div>
                    <div class="tag-list">
                        <a href="https://swiftonserver.com/tags/structured-concurrency/"><small>Structured Concurrency</small></a>
                    </div>
                </footer>
                            
                <section class="group">
                    <h4>Related posts</h4>                
                    <div class="grid grid-221">
                        <div class="card">
                            
                            
                            <div class="author-list">
                            </div>
                            <div class="meta">
                                <time datetime="2024/03/25">2024/03/25</time>
                                
                            </div>
                            
                            <h2 class="title"><a href="https://swiftonserver.com/structured-concurrency-and-shared-state-in-swift/" target="">Structured Concurrency and Shared State in Swift</a></h2>
                            <p>Learn how actors and sendable prevent race conditions in your concurrent code.</p>
                        
                            <div class="tag-list">
                            </div>
                        </div>
                    <div class="card">
                            
                            
                            <div class="author-list">
                            </div>
                            <div class="meta">
                                <time datetime="2024/03/19">2024/03/19</time>
                                
                            </div>
                            
                            <h2 class="title"><a href="https://swiftonserver.com/getting-started-with-structured-concurrency-in-swift/" target="">Getting Started with Structured Concurrency in Swift</a></h2>
                            <p>Learn how to apply structured concurrency in your applications, using task groups and other structured concepts.</p>
                        
                            <div class="tag-list">
                            </div>
                        </div>
                    </div>
                </section>
    
            </article>
        </div>
        
        <div>
            <div class="support">
                <a href="https://www.serversideswift.info/" target="_blank">
                    <img src="https://swiftonserver.com//images/logos/serversideswift.png" alt="Server-Side Swift Conference logo">
                </a>
                <h4>
                    <a href="https://www.serversideswift.info/" target="_blank">ServerSide.swift</a>
                </h4>
                <p>26th-27th September 2024. London, UK</p>
                <p>Discount code: <strong><a href="https://ti.to/serverside-swift/2024/discount/SWIFTONSERVER" target="_blank">SWIFTONSERVER</a></strong></p>
                <a class="cta" href="https://www.serversideswift.info/tickets/" target="_blank">Buy a ticket</a>
            </div>
            
            <aside id="toc">
                <h4>On this page</h4>
                <ul>
                    <li class="first-level">
                        <a href="#What%20is%20a%20Sequence?">What is a Sequence?</a>
                        <ul>
                            <li><a href="#IteratorProtocol">IteratorProtocol</a></li>
                        </ul>
                    </li>
        <li class="first-level">
                        <a href="#AsyncSequences">AsyncSequences</a>
                        <ul>
                            <li><a href="#Throwing%20Async%20Iterators">Throwing Async Iterators</a></li>
                        </ul>
                    </li>
        <li class="first-level">
                        <a href="#Using%20AsyncStream">Using AsyncStream</a>
                        <ul>
                            <li><a href="#Implementing%20AsyncStream">Implementing AsyncStream</a></li>
                <li><a href="#Parallising%20Work">Parallising Work</a></li>
                        </ul>
                    </li>
        <li class="first-level">
                        <a href="#Implementing%20Custom%20AsyncSequence">Implementing Custom AsyncSequence</a>
                        <ul>
                            <li><a href="#Cancellation">Cancellation</a></li>
                        </ul>
                    </li>
        <li class="first-level">
                        <a href="#Changes%20in%20Swift%206">Changes in Swift 6</a>
                        <ul>
                        </ul>
                    </li>
        <li class="first-level">
                        <a href="#Conclusion">Conclusion</a>
                        <ul>
                        </ul>
                    </li>
                </ul>
            </aside>
    
        </div>
    </div>
    
    </main>

    <footer id="site-footer">
        <div class="grid grid-421">
    
            <figure>
                <picture>
                    <source
                        srcset="https://swiftonserver.com/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                    >
                    <img
                        id="logo-image"
                        src="https://swiftonserver.com/images/logos/logo.png"
                        alt="Logo of Swift on server"
                        title="Swift on server"
                    >
                </picture>
            </figure>
            
            <div>
                <span style="display: block; height: 32px;">&nbsp;</span>
                <h4>Swift on server</h4>
                <p><small><a href="https://swiftonserver.com/" target="_blank">swiftonserver.com</a></small></p>
                <ul>
                    <li><a href="https://github.com/swift-on-server/" target="_blank">GitHub</a></li>
                    <li><a href="https://mastodon.social/@swiftonserver/" target="_blank">Mastodon</a></li>
                    <li><a href="https://swiftonserver.com/rss.xml" target="_blank">RSS</a></li>
                    <li><a href="https://swiftonserver.com/sitemap.xml" target="_blank">Sitemap</a></li>
                </ul>
            </div>
            
            <div>
                <a href="https://swiftonserver.com/authors/joannis-orlandos/">
                <img class="small rounded" src="https://swiftonserver.com/assets/authors/joannis-orlandos/joannis-orlandos.jpeg" alt="Joannis Orlandos">
                </a>
                <h4><a href="https://swiftonserver.com/authors/joannis-orlandos/">Joannis Orlandos</a></h4>
                <p><small><a href="https://unbeatable.software/" target="_blank">Unbeatable Software B.V.</a></small></p>
                <ul>
                    <li><a href="mailto:hello@unbeatable.software" target="_blank">Email</a></li>
                    <li><a href="https://github.com/Joannis" target="_blank">GitHub</a></li>
                    <li><a href="https://x.com/JoannisOrlandos" target="_blank">X (Twitter)</a></li>
                    <li><a href="https://mastodon.social/@joannis@fosstodon.org" target="_blank">Mastodon</a></li>
                </ul>
            </div>
            
            <div>
                <a href="https://swiftonserver.com/authors/tibor-bodecs/">
                <img class="small rounded" src="https://swiftonserver.com/assets/authors/tibor-bodecs/tibor-bodecs.jpeg" alt="Tibor Bödecs">
                </a>
                <h4><a href="https://swiftonserver.com/authors/tibor-bodecs/">Tibor Bödecs</a></h4>
                <p><small><a href="https://binarybirds.com/" target="_blank">Binary Birds Kft.</a></small></p>
                <ul>
                    <li><a href="mailto:mail.tib@gmail.com" target="_blank">Email</a></li>
                    <li><a href="https://github.com/tib/" target="_blank">GitHub</a></li>
                    <li><a href="https://x.com/tiborbodecs" target="_blank">X (Twitter)</a></li>
                    <li><a href="https://mastodon.social/@tiborbodecs" target="_blank">Mastodon</a></li>
                </ul>
            </div>
            
        </div>
        
        <section class="grid grid-221">
            <small>Swift on server &copy; 2022 - 2024</small>
            <small>This site was generated using <a href="https://swift.org/" target="_blank">Swift</a> & <a href="https://github.com/binarybirds/toucan" target="_blank">Toucan</a>.</small>
        </section>
    </footer>

    </div>

    

</body>
</html>
