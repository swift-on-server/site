<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>Getting Started with Structured Concurrency in Swift - Swift on Server</title>

        <meta name="description" content="Learn how to apply structured concurrency in your applications, using task groups and other structured concepts." />

        <meta property="og:title" content="Getting Started with Structured Concurrency in Swift - Swift on Server" />
        <meta property="og:description" content="Learn how to apply structured concurrency in your applications, using task groups and other structured concepts." />
        <meta property="og:url" content="https://swiftonserver.com/getting-started-with-structured-concurrency-in-swift/" />
        <meta property="og:image" content="https://swiftonserver.com/images/assets/getting-started-with-structured-concurrency-in-swift/cover.jpg" />

        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="Getting Started with Structured Concurrency in Swift - Swift on Server" />
        <meta name="twitter:description" content="Learn how to apply structured concurrency in your applications, using task groups and other structured concepts." />
        <meta name="twitter:image" content="https://swiftonserver.com/images/assets/getting-started-with-structured-concurrency-in-swift/cover.jpg" />

        <link rel="stylesheet" href="https://swiftonserver.com/css/style.css" />
        <link rel="stylesheet" href="https://swiftonserver.com/css/syntax.css" />

        <link rel="shortcut icon" href="https://swiftonserver.com/images/icons/favicon.ico" type="image/x-icon" />
        <link rel="shortcut icon" href="https://swiftonserver.com/images/icons/icon-320.png" type="image/png" />

        <script type="text/javascript" src="https://swiftonserver.com/js/tooltips.js" async></script>

        <link rel="apple-touch-icon" href="https://swiftonserver.com/images/icons/apple-touch-icon.png" />
        <link rel="apple-touch-icon" sizes="57x57" href="https://swiftonserver.com/images/icons/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="https://swiftonserver.com/images/icons/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon" sizes="76x76" href="https://swiftonserver.com/images/icons/apple-touch-icon-76x76.png" />
        <link rel="apple-touch-icon" sizes="114x114" href="https://swiftonserver.com/images/icons/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon" sizes="120x120" href="https://swiftonserver.com/images/icons/apple-touch-icon-120x120.png" />
        <link rel="apple-touch-icon" sizes="144x144" href="https://swiftonserver.com/images/icons/apple-touch-icon-144x144.png" />
        <link rel="apple-touch-icon" sizes="152x152" href="https://swiftonserver.com/images/icons/apple-touch-icon-152x152.png" />
        <link rel="apple-touch-icon" sizes="180x180" href="https://swiftonserver.com/images/icons/apple-touch-icon-180x180.png" />

    </head>

    <body>
        <header id="page-header">
            <a href="https://swiftonserver.com/">
                <figure>
                    <picture>
                        <source
                        srcset="https://swiftonserver.com/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                        />
                        <img
                        id="logo-image"
                        width="150"
                        height="150"
                        src="https://swiftonserver.com/images/logos/logo.png"
                        alt="Logo of Swift on server"
                        title="Swift on server"
                        />
                    </picture>
                </figure>
            </a>
        </header>

        <main>

            <article>
    <header>
        <section id="post-header" class="content-wrapper">
            <time datetime="2024/03/19">2024/03/19</time>
            <h1 class="title">Getting Started with Structured Concurrency in Swift</h1>
            <p class="excerpt">Learn how to apply structured concurrency in your applications, using task groups and other structured concepts.</p>
            <div class="meta">
                <span class="tag">Swift</span>
                <span class="tag">Structured Concurrency</span>
            </div>
            <img src="https://github.com/joannis.png" alt="Joannis Orlandos" class="author">
            <p>
                <span class="author">Written by: <a href="https://x.com/JoannisOrlandos" target="_blank">Joannis Orlandos</a> @ 
                <span class="author"><a href="https://unbeatable.software/" target="_blank">Unbeatable Software B.V.</a></span><br>
                <span class="reading-time">Reading time: 30 minutes</span><br>
            </p>
        </section>
    </header>

    <section class="content-wrapper">
        <hr>
    </section>

    <section id="contents" class="content-wrapper">
    
    <section class='introduction'><h1>Structured Concurrency in Swift</h1></section><section class='details literature'><p>Swift 5.5 introduced structured concurrency. The new way to write concurrent code that is more maintainable and easier to reason about. A lot of developers have been adopting concurrency in Swift. But few people understand what ‘<strong>structured</strong>’ means in this context, and how it helps you.</p><p>This guide will teach you all you need to know about structured concurrency in Swift. We’ll cover the basics of concurrency, and how structured concurrency is different from other concurrency models. By the end of this guide, you’ll be able to write any application in Swift using structured concurrency.</p><h2 id='What%20is%20Concurrency?'><a href='#What%20is%20Concurrency?'>What is Concurrency?</a></h2><p>Concurrency is the ability of different parts your code to run out-of-order or in partial order, without affecting the outcome. This allows for parallel execution of the concurrent units, which can improve the overall speed of the execution.</p><p>Imagine that you’re shopping for groceries with a friend. You both have a list of items to buy, and you decide to split up to save time. You both go to different parts of the store, and pick up the items on your list. You both finish at slightly different times, and meet up at the checkout. Instead of having to go through all the aisles together, you’re both able to solve part of the puzzle at the same time. The end result is the same, but you’ve saved time.</p><h3 id='Pre-Swift%205.5%20Concurrency'><a href='#Pre-Swift%205.5%20Concurrency'>Pre-Swift 5.5 Concurrency</a></h3><p>Concurrency has been a part of Swift for a long time, for example, through the use of <code><a href='https://swiftinit.org/docs/swift/dispatch/dispatchqueue'>DispatchQueue</a></code> and <code><a href='https://swiftinit.org/docs/swift/foundation/operationqueue'>OperationQueue</a></code>. In these models, you can submit work to a queue, and the queue will execute the work in the background. Often times, you’ll have to wait for the work to finish, either successfully or with an error.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xv'>DispatchQueue</span>.<span class='xv'>global</span>().<span class='xv'>async</span> {<span class='newline'>
</span>    <span class='xc'>// Offload some (heavy) work</span><span class='newline'>
</span>}</code></pre><p>In these models, you’re responsible for managing the lifecycle of the work. You’ll need to ensure that work is properly cancelled when it’s no longer needed.</p><p>When implementing a function that has callbacks, you’re responsible for calling the completion handler when the work is done. This can make it hard to debug and reason about the code, especially when you’re working with concurrent units.</p><p>Take the following example:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>func</span> <span class='xv'>fetchImage</span>(<span class='xv'>at</span> <span class='xv'>url</span>: <span class='xt'>URL</span>, <span class='xv'>completion</span>: <span class='xa'>@escaping</span> (<span class='xt'>Result</span>&lt;<span class='xt'>UIImage</span>, <span class='xt'>Error</span>&gt;) -&gt; <span class='xt'>Void</span>) {<span class='newline'>
</span>    <span class='xv'>URLSession</span>.<span class='xv'>shared</span>.<span class='xv'>dataTask</span>(<span class='xv'>with</span>: <span class='xv'>url</span>) { <span class='xv'>data</span>, <span class='xv'>response</span>, <span class='xv'>error</span> <span class='xk'>in</span><span class='newline'>
</span>        <span class='xk'>if</span> <span class='xk'>let</span> <span class='xv'>error</span> {<span class='newline'>
</span>            <span class='xv'>completion</span>(.<span class='xv'>failure</span>(<span class='xv'>error</span>))<span class='newline'>
</span>            <span class='xk'>return</span><span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='xk'>guard</span> <span class='xk'>let</span> <span class='xv'>data</span> = <span class='xv'>data</span>, <span class='xk'>let</span> <span class='xv'>image</span> = <span class='xv'>UIImage</span>(<span class='xv'>data</span>: <span class='xv'>data</span>) <span class='xk'>else</span> {<span class='newline'>
</span>            <span class='xv'>completion</span>(.<span class='xv'>failure</span>(<span class='xv'>NetworkError</span>.<span class='xv'>missingImage</span>))<span class='newline'>
</span>            <span class='xk'>return</span><span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='xv'>completion</span>(.<span class='xv'>success</span>(<span class='xv'>image</span>))<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>In this example, various bugs can arise. For example, in <code>if let error</code>, omitting the <code>return</code> statement will cause the completion handler to be called twice.</p><h3 id='Race%20Conditions'><a href='#Race%20Conditions'>Race Conditions</a></h3><p>When accessing shared state from concurrently running code, it’s critical to ensure that the state is accessed in a safe way. If the same value is accessed and modified at the same time, you can run into crashes called ‘race conditions’.</p><p>Race conditions need to be carefully and correctly solved. When using a mutex/lock to protect shared state, you need to ensure that this lock starts and ends at the right time. And when working with locks in long running calls such as network calls, you need to be careful to avoid performance bottlenecks. Finally, you can cause deadlocks when multiple functions that call each other access the same lock. Take the following example:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>final</span> <span class='xk'>class</span> <span class='xv'>ImageCache</span> {<span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>var</span> <span class='xv'>cache</span>: [<span class='xt'>URL</span>: <span class='xt'>UIImage</span>] = [:]<span class='newline'>
</span>    <span class='xk'>private</span> <span class='xk'>let</span> <span class='xv'>lock</span> = <span class='xv'>NSLock</span>()<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>image</span>(<span class='xv'>for</span> <span class='xv'>url</span>: <span class='xt'>URL</span>) -&gt; <span class='xt'>UIImage</span>? {<span class='newline'>
</span>        <span class='xv'>lock</span>.<span class='xv'>lock</span>()<span class='newline'>
</span>        <span class='xk'>defer</span> { <span class='xv'>lock</span>.<span class='xv'>unlock</span>() }<span class='newline'>
</span>        <span class='xk'>return</span> <span class='xv'>cache</span>[<span class='xv'>url</span>]<span class='newline'>
</span>    }<span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>loadImage</span>(<span class='xv'>for</span> <span class='xv'>url</span>: <span class='xt'>URL</span>) {<span class='newline'>
</span>        <span class='xv'>lock</span>.<span class='xv'>lock</span>()<span class='newline'>
</span>        <span class='xk'>defer</span> { <span class='xv'>lock</span>.<span class='xv'>unlock</span>() }<span class='newline'>
</span>        <span class='xc'>// This is covered by the lock</span><span class='newline'>
</span>        <span class='xk'>if</span> <span class='xv'>cache</span>.<span class='xv'>keys</span>.<span class='xv'>contains</span>(<span class='xv'>url</span>) { <span class='newline'>
</span>            <span class='xk'>return</span><span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='xv'>fetchImage</span>(<span class='xv'>at</span>: <span class='xv'>url</span>) { <span class='xv'>image</span> <span class='xk'>in</span><span class='newline'>
</span>            <span class='xk'>guard</span> <span class='xk'>case</span> .<span class='xv'>success</span>(<span class='xk'>let</span> <span class='xv'>image</span>) = <span class='xv'>image</span> <span class='xk'>else</span> { <span class='xk'>return</span> }<span class='newline'>
</span>            <span class='xc'>// This is not covered by the lock</span><span class='newline'>
</span>            <span class='xv'>cache</span>[<span class='xv'>url</span>] = <span class='xv'>image</span><span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>The above example is non-trivial. It’s not always obvious that you need to lock access to <code>image</code> twice. There are not one, but four traps here.</p><ol><li><p>It’s easy to forget to lock access to the cache.</p></li><li><p>One might lock access to the cache, but omit either the check for an existing image - or the assignment of the image.</p></li><li><p>When locking access to the cache, one might forget to unlock the lock. When returning a value, as seen in the <code>image(for:)</code> function, the lock should be unlocked after accessing the value, but before returning.</p></li><li><p>Finally, when locking access to the cache, unlocking could be implemented only after the fetching has completed.</p></li></ol><p>These are all common mistakes, and they’re hard to debug and reason about. This is where structured concurrency comes in.</p><p>Over the years, many patterns and abstractions have emerged to solve these problems. For example, the <code>Future</code> and <code>Promise</code> pattern is a common way to solve the problem of waiting for a value to be available. These abstractions are not part of the standard library, and are not always easy to work with or reason about. They’re also not part of the standard library, leading to a fragmented ecosystem.</p><h2 id='Structured%20Concurrency'><a href='#Structured%20Concurrency'>Structured Concurrency</a></h2><p>Swift has always been focused on safety and maintainability through <em>local reasoning</em>. Common examples are found in the type system, such as the use of value types. Because Array and Dictionary are value types, you can reason about them locally. You don’t need to know about other parts of the code, and how those other parts might be modifying a reference to the same array or dictionary. Because value types are copied when passed around, you can reason about them locally.</p><p>Similarly, Structured Concurrency is a language feature that is designed to write concurrent code that is more maintainable and easier to reason about. It’s designed to solve these problems, and is the recommended to write concurrent code that is maintainable and easy to reason about.</p><p>You’re probably familiar with structured programming, as it’s a paradigm that every Swift developer uses. By making use of a <em>structured control flow</em> through constructs such as if-statements, for-loops and switch-statements, you’re able to write code that is easy to reason about and maintain.</p><p>Structured Concurrency is the same concept, but applied to concurrent code. Functions in structured concurrency still have a clear entry and exit point. In Swift, this is done through the use of <code>async</code> functions and the <code>await</code> keyword.</p><h3 id='Async%20Functions'><a href='#Async%20Functions'>Async Functions</a></h3><p>An <code>async</code> function is a function that can pause and resume. Think of it as a function that can be split up into multiple parts.</p><p>When you order a pizza, you don’t have to wait for the pizza to be made and delivered. You can continue watching your favourite show, while the pizza is delivered to your doorstep. Just like async functions. Should you need to know when the pizza is delivered, you can <code>await</code> the delivery.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>func</span> <span class='xv'>watchTelevision</span>() <span class='xk'>async</span> <span class='xk'>throws</span> {<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>store</span> = <span class='xk'>await</span> <span class='xv'>PizzaStore</span>.<span class='xv'>discover</span>()<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>pizza</span> = <span class='xk'>await</span> <span class='xv'>store</span>.<span class='xv'>orderPizza</span>()<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>show</span> = <span class='xv'>startWatchingTV</span>()<span class='newline'>
</span>    <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>pizza</span>.<span class='xv'>eat</span>()<span class='newline'>
</span>    <span class='xk'>await</span> <span class='xv'>show</span>.<span class='xv'>watchUntilDone</span>()<span class='newline'>
</span>    <span class='xv'>show</span>.<span class='xv'>stopWatchingTV</span>()<span class='newline'>
</span>}</code></pre><p>Since structured concurrency leverages the structured programming paradigm, handling errors works the same as in synchronous code.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>func</span> <span class='xv'>watchTelevision</span>() <span class='xk'>async</span> <span class='xk'>throws</span> {<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>pizza</span> = <span class='xk'>await</span> <span class='xv'>store</span>.<span class='xv'>orderPizza</span>()<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>show</span> = <span class='xv'>startWatchingTV</span>()<span class='newline'>
</span>    <span class='xk'>do</span> {<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>show</span> = <span class='xv'>startWatchingTV</span>()<span class='newline'>
</span>        <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>pizza</span>.<span class='xv'>eat</span>()<span class='newline'>
</span>        <span class='xk'>await</span> <span class='xv'>show</span>.<span class='xv'>watchUntilDone</span>()<span class='newline'>
</span>    } <span class='xk'>catch</span> <span class='xv'>PizzaError</span>.<span class='xv'>notHungry</span> {<span class='newline'>
</span>        <span class='xc'>// No problem, we'll eat it later</span><span class='newline'>
</span>    } <span class='xk'>catch</span> <span class='xv'>PizzaError</span>.<span class='xv'>burnt</span> {<span class='newline'>
</span>        <span class='xc'>// Something went wrong, we'll have to stop watching TV</span><span class='newline'>
</span>        <span class='xv'>show</span>.<span class='xv'>stopWatchingTV</span>()<span class='newline'>
</span>        <span class='xk'>await</span> <span class='xv'>store</span>.<span class='xv'>complain</span>(<span class='xv'>about</span>: <span class='xv'>pizza</span>)<span class='newline'>
</span>        <span class='xk'>throw</span> <span class='xv'>error</span><span class='newline'>
</span>    }<span class='newline'>
</span>    <span class='xv'>show</span>.<span class='xv'>stopWatchingTV</span>()<span class='newline'>
</span>}</code></pre><h2 id='Structured%20Tasks'><a href='#Structured%20Tasks'>Structured Tasks</a></h2><p>The <code>Task</code> object is not the only way to run concurrent work. The simplest way of running an <code>async</code> function in parallel is using the <code>async let</code> construct. This is a <em>structured</em> way to start a task and let it run until you need the result:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>func</span> <span class='xv'>buyBooks</span>(<span class='xv'>from</span> <span class='xv'>bankAccount</span>: <span class='xt'>BankAccount</span>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; [<span class='xt'>Book</span>] {<span class='newline'>
</span>    <span class='xc'>// Resolve this concurrently</span><span class='newline'>
</span>    <span class='xk'>async</span> <span class='xk'>let</span> <span class='xv'>balance</span> = <span class='xk'>await</span> <span class='xv'>bankAccount</span>.<span class='xv'>checkBalance</span>()<span class='newline'>

</span>    <span class='xk'>let</span> <span class='xv'>store</span> = <span class='xk'>await</span> <span class='xv'>BookStore</span>.<span class='xv'>discover</span>()<span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>budget</span> = <span class='xk'>await</span> <span class='xv'>balance</span><span class='newline'>
</span>    <span class='xk'>var</span> <span class='xv'>boughtBooks</span>: [<span class='xt'>Book</span>] = []<span class='newline'>
</span>    <span class='xk'>for</span> <span class='xk'>await</span> <span class='xv'>book</span> <span class='xk'>in</span> <span class='xv'>store</span>.<span class='xv'>broweBooks</span>() <span class='xk'>where</span> <span class='xv'>book</span>.<span class='xv'>price</span> <span class='xo'>&lt;=</span> <span class='xv'>budget</span> {<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>order</span> = <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>book</span>.<span class='xv'>buy</span>()<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>book</span> = <span class='xk'>await</span> <span class='xv'>order</span>.<span class='xv'>delivery</span>()<span class='newline'>
</span>        <span class='xv'>budget</span> <span class='xo'>-=</span> <span class='xv'>book</span>.<span class='xv'>price</span><span class='newline'>
</span>        <span class='xv'>boughtBooks</span>.<span class='xv'>append</span>(<span class='xv'>book</span>)<span class='newline'>
</span>    }<span class='newline'>
</span>    <span class='xk'>return</span> <span class='xv'>boughtBooks</span><span class='newline'>
</span>}</code></pre><p>When this <code>async let</code> is not <code>await</code>ed for, it will continue to run in the background until the end of the function. If the function returns without awaiting the <code>async let</code>, the task will be cancelled.</p><p>The <code>async let</code> pattern is helpful for individual pieces of work that need to run concurrently. But it doesn’t help when needing to run multiple pieces of work concurrently in a structured way. For that, there are <strong>task groups</strong>.</p><h3 id='Sequences'><a href='#Sequences'>Sequences</a></h3><p>Like how a for-loop iterates over a sequence of items, a for-await-in loop iterates over a sequence of async items.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>struct</span> <span class='xv'>Books</span>: <span class='xt'>AsyncSequence</span> {<span class='newline'>
</span>    <span class='xk'>typealias</span> <span class='xv'>Element</span> = <span class='xt'>Book</span><span class='newline'>
</span>    <span class='xo'>...</span><span class='newline'>
</span>}<span class='newline'>

</span><span class='xk'>func</span> <span class='xv'>browseBooks</span>() -&gt; <span class='xt'>Books</span> {}<span class='newline'>

</span><span class='xk'>func</span> <span class='xv'>buyAllBooks</span>() <span class='xk'>async</span> <span class='xk'>throws</span> {<span class='newline'>
</span>    <span class='xk'>for</span> <span class='xk'>await</span> <span class='xv'>book</span> <span class='xk'>in</span> <span class='xv'>browseBooks</span>() {<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>order</span> = <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>book</span>.<span class='xv'>buy</span>()<span class='newline'>
</span>        <span class='xk'>await</span> <span class='xv'>order</span>.<span class='xv'>delivery</span>()<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>This is a powerful feature, as it allows you to easily reason about <em>streams</em> of data. On iOS, this can be a stream of keyboard events, StoreKit purchases, notifications or sensor data. For backend developers, this can be a WebSocket, a database query or the incoming connections on a TCP server. If you’re interested in that, please check out our tutorial on <a href='../using-swiftnio-channels'>SwiftNIO Channels</a>.</p><p>If you’re familiar with the Combine framework, this might sound similar to a <code>Publisher</code>. AsyncSequences have many of the same features as Combine’s Publishers. Especially with <a target='_blank' rel='external' href='https://github.com/apple/swift-async-algorithms'>swift-async-algorithms</a>, AsyncSequence receive many of the same perks that a Publisher has.</p><p>AsyncSequences are part of the standard library, and are designed similarly to the existing <code>Sequence</code> protocol. You can create an <code>AsyncIterator</code> from them.  The iterator has a <code>mutating func next() async throws -&gt; Element?</code>.</p><p>This allows you to write a longer control flow that expect multiple results, such as the head and body of an HTTP request. You can use a <code>for-await-in</code> loop to iterate over the sequence of results, or manually iterate over the sequence using the <code>next()</code> method.</p><p>Now, a common request; “How can I await the delivery of these books concurrently?”</p><h2 id='Tasks'><a href='#Tasks'>Tasks</a></h2><p>A task is a concurrent unit of work. In concurrency, many tasks can run in parallel.</p><p>The <em>easiest</em> way to create a task is using the <strong>unstructured</strong> <code>Task</code> type. It’s used to run a piece of code concurrently in the background, similar to <code>DispatchQueue.global().async {}</code>. In addition, you can manage it’s lifecycle by <code>cancel()</code>ing it. Finally, you can also <code>await</code> its <code>value</code> for it to finish.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>func</span> <span class='xv'>buyBooks</span>() {<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>store</span> = <span class='xk'>await</span> <span class='xv'>BookStore</span>.<span class='xv'>discover</span>()<span class='newline'>
</span>    <span class='xk'>for</span> <span class='xk'>await</span> <span class='xv'>book</span> <span class='xk'>in</span> <span class='xv'>store</span>.<span class='xv'>browseBooks</span>() {<span class='newline'>
</span>        <span class='xv'>Task</span> {<span class='newline'>
</span>            <span class='xk'>let</span> <span class='xv'>order</span> = <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>book</span>.<span class='xv'>buy</span>()<span class='newline'>
</span>            <span class='xk'>await</span> <span class='xv'>order</span>.<span class='xv'>delivery</span>()<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>This looks great in theory, but the <code>Task</code> object is <em>not</em> structured. It’s not clear when the task starts, when it ends, and what happens when it’s cancelled. You’re required to manage the lifecycle of the task yourself, and don’t even need to await the result or handle errors. This is inherently unsafe and re-introduces the problems that structured concurrency is designed to solve.</p><p>It is very much a part of the structured concurrency model. But think of it as an “escape hatch” when there’s no other context or task in which your code can run. In almost every application, you’ll have <em>some</em> entrypoint at which you can start with a task. For example, your <code>@main</code> annotated entrypoint can be marked as <code>static func main() async throws</code> and you can start your application from there.</p><p>In SwiftUI apps, concurrent work can be started from within the <code>.task { }</code> view modifier. Not only does this allow running <code>async</code> work, but it also cancels that task when the view is no longer needed. That way your dependencies can discard heavy work initiated by the view that the user is no longer interested in.</p><h3 id='The%20Task%20Hierarchy'><a href='#The%20Task%20Hierarchy'>The Task Hierarchy</a></h3><p>Tasks in structured concurrency are part of a hierarchy. This means that a task can create child tasks, and that the child tasks are automatically cancelled when the parent task is cancelled. Both structured and unstructured tasks are part of this hierarchy. Unstructured tasks do not reap all of the same benefits as structured tasks.</p><p>Like in structured programming, structured concurrency has a stack. This allows reading a stack trace to understand the flow of the program. This is especially helpful when debugging, or when reading a crash or error report.</p><p>When using unstructured tasks, you’re not able to see the stack trace outside of the spawned task. This makes it harder to debug, and loses your ability to leverage some Xcode Instruments.</p><h3 id='Task%20Local%20Values'><a href='#Task%20Local%20Values'>Task Local Values</a></h3><p>Since tasks can run on many different threads, there is (generally) no guarantee that a task will run on the same thread between suspension points. This means that thread-local is not available to store values that are specific to a task in structured concurrency.</p><p>A replacement for thread-local storage is task-local storage. This is a way to store values that are specific to a task. By using the <code>TaskLocal</code> property wrapper to store values that are specific to a task.</p><p>Here’s an example of how a <code>TaskLocal</code> stores the currently authenticated user in a web server:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>struct</span> <span class='xv'>UserMiddleware</span>: <span class='xt'>Middleware</span> {<span class='newline'>
</span>    <span class='xa'>@TaskLocal</span> <span class='xk'>static</span> <span class='xk'>var</span> <span class='xv'>currentUser</span>: <span class='xt'>User</span>?<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>db</span>: <span class='xt'>Database</span><span class='newline'>

</span>    <span class='xk'>func</span> <span class='xv'>handleRequest</span>(<span class='newline'>
</span>        _ <span class='xv'>request</span>: <span class='xt'>HTTPRequest</span>,<span class='newline'>
</span>        <span class='xv'>next</span>: <span class='xt'>HTTPResponder</span><span class='newline'>
</span>    ) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>HTTPResponse</span> {<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>token</span> = <span class='xk'>try</span> <span class='xv'>request</span>.<span class='xv'>parseJWT</span>()<span class='newline'>
</span>        <span class='xk'>let</span> <span class='xv'>user</span> = <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>db</span>.<span class='xv'>getUser</span>(<span class='xv'>byId</span>: <span class='xv'>token</span>.<span class='xv'>sub</span>)<span class='newline'>
</span>        <span class='xk'>return</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>HTTPServer</span>.<span class='xv'>$currentUser</span>.<span class='xv'>withValue</span>(<span class='xv'>user</span>) {<span class='newline'>
</span>            <span class='xk'>return</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>next</span>.<span class='xv'>respond</span>(<span class='xv'>to</span>: <span class='xv'>request</span>)<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>Now that the TaskLocal variable is set, it’s accessible from any code called within the <code>withValue</code> block. For example:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>func</span> <span class='xv'>respond</span>(<span class='xv'>to</span> <span class='xv'>request</span>: <span class='xt'>HTTPRequest</span>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>HTTPResponse</span> {<span class='newline'>
</span>    <span class='xk'>guard</span> <span class='xk'>let</span> <span class='xv'>currentUser</span> = <span class='xv'>UserMiddleware</span>.<span class='xv'>currentUser</span> <span class='xk'>else</span> {<span class='newline'>
</span>        <span class='xk'>throw</span> <span class='xv'>HTTPError</span>.<span class='xv'>unauthorized</span><span class='newline'>
</span>    }<span class='newline'>
</span>    <span class='xc'>// ...</span><span class='newline'>
</span>}</code></pre><h3 id='Task%20Cancellation'><a href='#Task%20Cancellation'>Task Cancellation</a></h3><p>In structured concurrency, tasks are automatically cancelled when their parent task is cancelled. This is a powerful feature, as it allows you to cancel all of a task’s dependencies at once. This is especially helpful when you’re writing a server.</p><p>Let’s say you’re writing a web server, where your route generates a huge excel file. If the client cancels the request, you’ll want to cancel the generation of the excel file. Continuing to generate the file is a waste of resources, and can lead to intentional and unintentional denial of service attacks.</p><p>In structured concurrency, you can use the <code><a href='https://swiftinit.org/docs/swift/_concurrency/task'>Task</a></code> object to cancel a task. This is a structured way to cancel a task, and it’s clear when the task is cancelled. You can also use the <code><a href='https://swiftinit.org/docs/swift/_concurrency/task'>Task</a></code> object to check if a task is cancelled, and to handle the cancellation.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>if</span> <span class='xv'>Task</span>.<span class='xv'>isCancelled</span> {<span class='newline'>
</span>    <span class='xk'>return</span><span class='newline'>
</span>}</code></pre><p>This is a structured way to check if a task is cancelled, and to handle the cancellation. It’s clear when the task is cancelled, and you can handle the cancellation in a structured way.</p><p>You can also check if a task is cancelled using the <code><a href='https://swiftinit.org/docs/swift/_concurrency/task.checkcancellation'>checkCancellation</a></code> method. This is a structured way to check if a task is cancelled, and to handle the cancellation. It’s clear when the task is cancelled, and you can handle the cancellation in a structured way.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>try</span> <span class='xv'>Task</span>.<span class='xv'>checkCancellation</span>()</code></pre><p>This will throw a <code><a href='https://swiftinit.org/docs/swift/_concurrency/cancellationerror'>CancellationError</a></code> if the task is cancelled. You can catch this error and handle the cancellation in a structured way.</p><h3 id='Blocking%20and%20Sleeping%20Tasks'><a href='#Blocking%20and%20Sleeping%20Tasks'>Blocking and Sleeping Tasks</a></h3><p>If you have blocking or heavy work that you want to run concurrently, you’ll need to do so outside of the structured concurrency model. This is because blocking or heavy work can cause a performance bottleneck in the global concurrent executor. SwiftNIO has the <code><a href='https://swiftinit.org/docs/swift-nio/nioposix/niothreadpool'>NIOThreadPool</a></code> that you can use to run blocking work concurrently. For iOS users, it may be wise to use a <code><a href='https://swiftinit.org/docs/swift/dispatch/dispatchqueue'>DispatchQueue</a></code> for these scenarios.</p><p>If you do decide to add computationally heavy code in structured concurrency, you can use <code>await Task.yield()</code> to yield the current task. This will allow your Task Executor to run other tasks. Doing so can prevent lag spikes, such as UI freezes those that happen on iOS when blocking the main thread.</p><p><strong>Note:</strong> Swift 6 will be able to address these issues, through the addition of custom Task Executors. More on that later.</p><p>When finding yourself in a situation where you need to delay a task, you can use the <code>Task.sleep</code> method. It’s similar to your regular <code>sleep</code> function, but rather than blocking the entire thread, it only suspends the task.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>Task</span>.<span class='xv'>sleep</span>(<span class='xv'>for</span>: .<span class='xv'>seconds</span>(<span class='xn'>10</span>))</code></pre><p>An extra feature of <code>Task.sleep</code> is that it can be cancelled. If the task is cancelled while it’s sleeping, the sleep will be interrupted and throw a <code><a href='https://swiftinit.org/docs/swift/_concurrency/cancellationerror'>CancellationError</a></code>.</p><h3 id='Cancellation%20Handlers'><a href='#Cancellation%20Handlers'>Cancellation Handlers</a></h3><p>When a task is cancelled, you might want to clean up resources or perform some other action to handle the cancellation. You can use a cancellation handler to do this. A cancellation handler is a piece of code that is run when a task is cancelled.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>func</span> <span class='xv'>getData</span>() <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>HTTPResponse</span> {<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>httpClient</span> = <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>HTTPClient</span>.<span class='xv'>connect</span>(<span class='xv'>to</span>: <span class='xs'>"https://api.example.com"</span>)<span class='newline'>
</span>    <span class='xk'>return</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>withTaskCancellationHandler</span> {<span class='newline'>
</span>        <span class='xc'>// This will run normally, and does the actual work</span><span class='newline'>
</span>        <span class='xc'>// On cancellation, it will still find that `Task.isCancelled == true`</span><span class='newline'>
</span>        <span class='xc'>// In addition, Task.sleep will throw a CancellationError</span><span class='newline'>
</span>        <span class='xc'>// But if the HTTPClient doens't support cancellation,</span><span class='newline'>
</span>        <span class='xc'>// it will continue to run until it's done</span><span class='newline'>
</span>        <span class='xk'>return</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>httpClient</span>.<span class='xv'>get</span>(<span class='xs'>"/data"</span>)<span class='newline'>
</span>    } <span class='xv'>onCancel</span>: {<span class='newline'>
</span>        <span class='xc'>// If the task is cancelled, this callback will run</span><span class='newline'>
</span>        <span class='xc'>// and clean up the HTTP client</span><span class='newline'>
</span>        <span class='xc'>// This allows users to implement cancellation manunally if needed</span><span class='newline'>
</span>        <span class='xv'>httpClient</span>.<span class='xv'>shutdown</span>()<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><h2 id='Task%20Groups'><a href='#Task%20Groups'>Task Groups</a></h2><p>One can order ten items off your favourite book store. But in the real world, you don’t want to <code>await</code> for the first book before ordering the next one. For that, we can use a <code><a href='https://swiftinit.org/docs/swift/_concurrency/taskgroup'>TaskGroup</a></code>:</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>func</span> <span class='xv'>buyBooks</span>() <span class='xk'>async</span> <span class='xk'>throws</span> {<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>store</span> = <span class='xk'>await</span> <span class='xv'>BookStore</span>.<span class='xv'>discover</span>()<span class='newline'>
</span>    <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>withThrowingTaskGroup</span>(<span class='xv'>of</span>: <span class='xv'>Book</span>.<span class='xk'>self</span>) { <span class='xv'>taskGroup</span> <span class='xk'>in</span><span class='newline'>
</span>        <span class='xk'>for</span> <span class='xk'>await</span> <span class='xv'>book</span> <span class='xk'>in</span> <span class='xv'>store</span>.<span class='xv'>browseBooks</span>() {<span class='newline'>
</span>            <span class='xv'>taskGroup</span>.<span class='xv'>addTask</span> {<span class='newline'>
</span>                <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>book</span>.<span class='xv'>buy</span>()<span class='newline'>
</span>            }<span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='xc'>// The task group will automatically await all tasks</span><span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><p>This is a structured way to run multiple pieces of work concurrently. It’s clear when the tasks start and when they end. You can run many pieces of work in parallel. And you can await all tasks being completed, and get an error if any one of them fails.</p><p>The above task group can throw errors, but not all task groups need to throw. If you use <code><a href='https://swiftinit.org/docs/swift/_concurrency.withtaskgroup(of:returning:body:)'>withTaskGroup(of:returning:body:)</a></code>, you’ll be able to run tasks that don’t throw, and you won’t need to handle errors.</p><p>In the above example, <code>withThrowingTaskGroup(of: Book.self)</code> specifies that each task <em>must</em> produce a <code>Book</code> result if successful. In some cases, the result of the task is not necessary. In this case however, the results are helpful to collect the books that were bought.</p><p>To solve that, use the <code>reduce</code> function on the task group. This is a structured way to run multiple pieces of work concurrently, and to reduce the results into a single value.</p><pre class='snippet'><code class='language-swift'><span class='newline'></span><span class='xk'>func</span> <span class='xv'>buyBooks</span>() <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; [<span class='xt'>Book</span>] {<span class='newline'>
</span>    <span class='xk'>let</span> <span class='xv'>store</span> = <span class='xk'>await</span> <span class='xv'>BookStore</span>.<span class='xv'>discover</span>()<span class='newline'>
</span>    <span class='xk'>return</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>withThrowingTaskGroup</span>(<span class='xv'>of</span>: <span class='xv'>Book</span>.<span class='xk'>self</span>) { <span class='xv'>taskGroup</span> <span class='xk'>in</span><span class='newline'>
</span>        <span class='xk'>for</span> <span class='xk'>await</span> <span class='xv'>book</span> <span class='xk'>in</span> <span class='xv'>store</span>.<span class='xv'>browseBooks</span>() {<span class='newline'>
</span>            <span class='xv'>taskGroup</span>.<span class='xv'>addTask</span> {<span class='newline'>
</span>                <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>book</span>.<span class='xv'>buy</span>()<span class='newline'>
</span>            }<span class='newline'>
</span>        }<span class='newline'>
</span>        <span class='xc'>// Completes when all tasks have completed</span><span class='newline'>
</span>        <span class='xk'>return</span> <span class='xk'>try</span> <span class='xk'>await</span> <span class='xv'>taskGroup</span>.<span class='xv'>reduce</span>(<span class='xv'>into</span>: []) { <span class='xv'>books</span>, <span class='xv'>book</span> <span class='xk'>in</span><span class='newline'>
</span>            <span class='xv'>books</span>.<span class='xv'>append</span>(<span class='xv'>book</span>)<span class='newline'>
</span>        }<span class='newline'>
</span>    }<span class='newline'>
</span>}</code></pre><h3 id='Discarding%20Task%20Groups'><a href='#Discarding%20Task%20Groups'>Discarding Task Groups</a></h3><p>In some cases, you might not be interested in the result of the task group. For example, you might want to run a number of tasks concurrently, but these tasks don’t return results. In that case, you can use <code><a href='https://swiftinit.org/docs/swift/_concurrency.withdiscardingtaskgroup(returning:body:)'>withDiscardingTaskGroup(returning:body:)</a></code> and <code><a href='https://swiftinit.org/docs/swift/_concurrency.withthrowingdiscardingtaskgroup(returning:body:)'>withThrowingDiscardingTaskGroup(returning:body:)</a></code> from iOS 17 and macOS 14. This is a structured way to run multiple pieces of work concurrently, without needing to retain results.</p><p>The regular task groups create a collection of results, which you can then iterate over. In some cases, such as a TCP server, this collection of results is not needed and grow indefinitely. In that case, you’ll want to use a discarding task group to prevent an ever-growing collection of results. Note that <code>Void</code> results are still stored and occupy a small amount of memory!</p><h2 id='Conclusion'><a href='#Conclusion'>Conclusion</a></h2><p>Structured concurrency is a powerful feature that was introduced with Swift 5.5. When writing your concurrenct code in a structured way, it’s easier to reason about your code and maintain it.</p><p>Almost every application that you write will also have some form of shared state. In the next article, <a href='../structured-concurrency-and-shared-state-in-swift'>Sendable and Shared Mutable State</a>, we’ll cover how Swift’s actors, actor isolation and Sendable checking empower you to write race-condition free code.</p></section><div style='display: none;' id='ss:tooltips'><a href='/docs/swift/dispatch/dispatchqueue'><pre><code><span class='xk'>class</span> <span class='xv'>DispatchQueue</span></code></pre></a><a href='/docs/swift/foundation/operationqueue'><pre><code><span class='xk'>class</span> <span class='xv'>OperationQueue</span></code></pre></a><a href='/docs/joannis.swiftonserver-site/__swiftonserver_org/using-swiftnio-channels'><p>SwiftNIO revolves around networking. In SwiftNIO, reads and writes happen using a <code>Channel</code>.</p></a><a href='/docs/swift/_concurrency/task'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>Task</span>&lt;<span class='xu'>Success</span>, <span class='xu'>Failure</span>&gt; <span class='xk'>where</span> <span class='xt'>Success</span> : <span class='xt'>Sendable</span>, <span class='xt'>Failure</span> : <span class='xt'>Error</span></code></pre><p>A unit of asynchronous work.</p></a><a href='/docs/swift/_concurrency/task.checkcancellation'><pre><code><span class='xk'>static</span> <span class='xk'>func</span> <span class='xv'>checkCancellation</span>(<wbr>) <span class='xk'>throws</span></code></pre><p>Throws an error if the task was canceled.</p></a><a href='/docs/swift/_concurrency/cancellationerror'><pre><code><span class='xk'>struct</span> <span class='xv'>CancellationError</span></code></pre><p>An error that indicates a task was canceled.</p></a><a href='/docs/swift-nio/nioposix/niothreadpool'><pre><code><span class='xk'>final</span> <span class='xk'>class</span> <span class='xv'>NIOThreadPool</span></code></pre><p>A thread pool that should be used if some (kernel thread) blocking work needs to be performed for which no non-blocking API exists.</p></a><a href='/docs/swift/_concurrency/taskgroup'><pre><code><span class='xa'>@frozen</span> <span class='xk'>struct</span> <span class='xv'>TaskGroup</span>&lt;<span class='xu'>ChildTaskResult</span>&gt; <span class='xk'>where</span> <span class='xt'>ChildTaskResult</span> : <span class='xt'>Sendable</span></code></pre><p>A group that contains dynamically created child tasks.</p></a><a href='/docs/swift/_concurrency.withtaskgroup(of:returning:body:)'><pre><code><span class='xk'>func</span> <span class='xv'>withTaskGroup</span>&lt;<span class='xu'>ChildTaskResult</span>, <span class='xu'>GroupResult</span>&gt;(<span class='xi'></span><span class='xv'>of</span> <span class='xb'>childTaskResultType</span>: <span class='xt'>ChildTaskResult</span>.<span class='xk'>Type</span>, <span class='xi'></span><span class='xv'>returning</span> <span class='xb'>returnType</span>: <span class='xt'>GroupResult</span>.<span class='xk'>Type</span> = <span class='xv'>GroupResult</span>.<span class='xk'>self</span>, <span class='xi'></span><span class='xv'>body</span>: (<span class='xk'>inout</span> <span class='xt'>TaskGroup</span>&lt;<span class='xt'>ChildTaskResult</span>&gt;) <span class='xk'>async</span> -&gt; <span class='xt'>GroupResult</span><wbr>) <span class='xk'>async</span> -&gt; <span class='xt'>GroupResult</span> <span class='xk'>where</span> <span class='xt'>ChildTaskResult</span> : <span class='xt'>Sendable</span></code></pre><p>Starts a new scope that can contain a dynamic number of child tasks.</p></a><a href='/docs/swift/_concurrency.withdiscardingtaskgroup(returning:body:)'><pre><code><span class='xk'>func</span> <span class='xv'>withDiscardingTaskGroup</span>&lt;<span class='xu'>GroupResult</span>&gt;(<span class='xi'></span><span class='xv'>returning</span> <span class='xb'>returnType</span>: <span class='xt'>GroupResult</span>.<span class='xk'>Type</span> = <span class='xv'>GroupResult</span>.<span class='xk'>self</span>, <span class='xi'></span><span class='xv'>body</span>: (<span class='xk'>inout</span> <span class='xt'>DiscardingTaskGroup</span>) <span class='xk'>async</span> -&gt; <span class='xt'>GroupResult</span><wbr>) <span class='xk'>async</span> -&gt; <span class='xt'>GroupResult</span></code></pre><p>Starts a new scope that can contain a dynamic number of child tasks.</p></a><a href='/docs/swift/_concurrency.withthrowingdiscardingtaskgroup(returning:body:)'><pre><code><span class='xk'>func</span> <span class='xv'>withThrowingDiscardingTaskGroup</span>&lt;<span class='xu'>GroupResult</span>&gt;(<span class='xi'></span><span class='xv'>returning</span> <span class='xb'>returnType</span>: <span class='xt'>GroupResult</span>.<span class='xk'>Type</span> = <span class='xv'>GroupResult</span>.<span class='xk'>self</span>, <span class='xi'></span><span class='xv'>body</span>: (<span class='xk'>inout</span> <span class='xt'>ThrowingDiscardingTaskGroup</span>&lt;<span class='xk'>any</span> <span class='xt'>Error</span>&gt;) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>GroupResult</span><wbr>) <span class='xk'>async</span> <span class='xk'>throws</span> -&gt; <span class='xt'>GroupResult</span></code></pre><p>Starts a new scope that can contain a dynamic number of child tasks.</p></a><a href='/docs/joannis.swiftonserver-site/__swiftonserver_org/structured-concurrency-and-shared-state-in-swift'><p>When working with concurrent code, you’ll often need to share state between tasks. Using reference types such as a <code>class</code> allows you to share state between different threads and tasks. This can lead to race conditions where two tasks are trying to access the same state at the same time.</p></a></div>
        
    </section>

    <section id="about-author" class="content-wrapper">
        <img src="https://github.com/joannis.png" alt="Joannis Orlandos" class="author">
        <h4>About Joannis Orlandos</h4>
        <p class="author-about">Joannis is a seasoned member of the Swift Server WorkGroup, and the co-founder of Unbeatable Software B.V. If you're looking to elevate your team's capabilities or need expert guidance on Swift backend development, consider hiring him.</p>

        <a href="https://unbeatable.software/mentoring-and-training" target="_blank" class="author-cta">Get in touch with Joannis</a>
    </section>
</article>


        </main>

        <footer>
            <section class="content-wrapper">
                <figure>
                    <picture>
                        <source
                        srcset="https://swiftonserver.com/images/logos/logo~dark.png"
                        media="(prefers-color-scheme: dark)"
                        />
                        <img
                        id="logo-image"
                        width="80"
                        height="80"
                        src="https://swiftonserver.com/images/logos/logo.png"
                        alt="Logo of Swift on server"
                        title="Swift on server"
                        />
                    </picture>
                </figure>

                <p>This site was generated using the <a href="https://swift.org/" target="_blank">Swift</a> programming language.</p>
                <p class="small">Created by <a href="https://x.com/JoannisOrlandos" target="_blank">Joannis Orlandos</a> & <a href="https://x.com/tiborbodecs">Tibor Bödecs</a> &copy; 2024.</p>

                <p>
                <a href="https://swiftonserver.com/">Home</a> ·
                <a href="https://swiftonserver.com/rss.xml" target="_blank">RSS</a> ·
                <a href="https://swiftonserver.com/sitemap.xml" target="_blank">Sitemap</a>
                </p>


            </section>
        </footer>
    </body>
</html>
